<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - T·∫°o B√†i Vi·∫øt M·ªõi | B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng</title>
  <meta name="robots" content="noindex, nofollow">

  <!-- TinyMCE with Domain-Restricted API Key -->
  <script src="https://cdn.tiny.cloud/1/pnjrxidpb2mr61lce6gwowjzx0yxonun8dz02n46fu0ewe84/tinymce/6/tinymce.min.js"
    referrerpolicy="origin" onerror="handleTinyMCELoadError()"></script>

  <!-- Fallback TinyMCE CDN -->
  <script>
    function handleTinyMCELoadError() {
      console.log('‚ö†Ô∏è Primary TinyMCE CDN failed, trying fallback...');
      updateEditorStatus('‚ö†Ô∏è ƒêang th·ª≠ CDN d·ª± ph√≤ng...', 'error');

      const fallbackScript = document.createElement('script');
      fallbackScript.src = 'https://cdn.jsdelivr.net/npm/tinymce@6/tinymce.min.js';
      fallbackScript.onerror = function () {
        console.error('‚ùå All TinyMCE CDNs failed');
        updateEditorStatus('‚ùå T·∫•t c·∫£ CDN th·∫•t b·∫°i. Ki·ªÉm tra internet v√† reload.', 'error');
      };
      fallbackScript.onload = function () {
        console.log('‚úÖ Fallback TinyMCE loaded successfully');
        updateEditorStatus('üîÑ ƒêang kh·ªüi t·∫°o editor...', '');
      };
      document.head.appendChild(fallbackScript);
    }
  </script>

  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- News Template Engine -->
  <script src="/news-template-engine.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f8fafc;
      color: #1a202c;
      line-height: 1.6;
    }

    .admin-header {
      background: #2d3748;
      color: white;
      padding: 1rem 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .admin-header h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .admin-container {
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    .editor-form {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }

    .form-section {
      margin-bottom: 2rem;
    }

    .form-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    .form-group label {
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #4a5568;
    }

    .form-input {
      padding: 0.75rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: #3182ce;
      box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }

    .editor-container {
      margin: 2rem 0;
    }

    .editor-status {
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
      background-color: #f7fafc;
      border: 1px solid #e2e8f0;
      color: #4a5568;
    }

    .editor-status.success {
      background-color: #f0fff4;
      border-color: #9ae6b4;
      color: #2f855a;
    }

    .editor-status.error {
      background-color: #fed7d7;
      border-color: #fc8181;
      color: #c53030;
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid #e2e8f0;
    }

    /* Status Indicator Styles */
    .status-indicator {
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
    }

    .status-indicator.draft {
      background-color: #fef3c7;
      color: #92400e;
      border: 1px solid #f59e0b;
    }

    .status-indicator.published {
      background-color: #d1fae5;
      color: #065f46;
      border: 1px solid #10b981;
    }

    /* Action Button Styles */
    .save-draft-btn {
      background: #6b7280;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .save-draft-btn:hover {
      background: #4b5563;
    }

    .save-publish-btn {
      background: #059669;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .save-publish-btn:hover {
      background: #047857;
    }

    .auto-deploy-btn {
      background: #dc2626;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .auto-deploy-btn:hover {
      background: #b91c1c;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: #3182ce;
      color: white;
    }

    .btn-primary:hover {
      background: #2c5aa0;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-secondary:hover {
      background: #cbd5e0;
    }

    .btn-success {
      background: #38a169;
      color: white;
    }

    .btn-success:hover {
      background: #2f855a;
    }

    .preview-container {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 2rem;
      margin-top: 2rem;
      display: none;
    }

    .preview-meta {
      background: #f7fafc;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .image-upload {
      border: 2px dashed #cbd5e0;
      border-radius: 6px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .image-upload:hover {
      border-color: #3182ce;
    }

    .image-upload.dragover {
      border-color: #3182ce;
      background: #ebf8ff;
    }

    .uploaded-images {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .uploaded-image {
      position: relative;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #e2e8f0;
    }

    .uploaded-image img {
      width: 100%;
      height: 100px;
      object-fit: cover;
      display: block;
    }

    .image-actions {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .image-type {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border-radius: 3px;
      padding: 0.125rem 0.375rem;
      font-size: 0.7rem;
      font-weight: 500;
      text-align: center;
      white-space: nowrap;
    }

    .image-btn {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .status-message {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }

    .status-success {
      background: #f0fff4;
      color: #22543d;
      border: 1px solid #c6f6d5;
    }

    .status-error {
      background: #fff5f5;
      color: #742a2a;
      border: 1px solid #fed7d7;
    }

    /* Error Modal Styles */
    .error-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .error-modal.show {
      display: flex;
    }

    .error-modal-content {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 90%;
      text-align: center;
      animation: modalSlideIn 0.3s ease-out;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .error-modal-icon {
      font-size: 4rem;
      color: #e53e3e;
      margin-bottom: 1rem;
    }

    .error-modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 1rem;
    }

    .error-modal-message {
      color: #4a5568;
      margin-bottom: 2rem;
      line-height: 1.5;
    }

    .error-modal-button {
      background: linear-gradient(135deg, #0060ae, #0087d2);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 96, 174, 0.3);
    }

    .error-modal-button:hover {
      background: linear-gradient(135deg, #004d8a, #006bb3);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 96, 174, 0.4);
    }

    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .action-buttons {
        flex-direction: column;
      }

      .admin-container {
        padding: 0 0.5rem;
      }

      .error-modal-content {
        padding: 1.5rem;
        margin: 1rem;
      }
    }
  </style>
</head>

<body>
  <header class="admin-header">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h1>üìù So·∫°n th·∫£o b√†i vi·∫øt</h1>
      <div style="display: flex; gap: 1rem; align-items: center;">
        <a href="admin-dashboard.html"
          style="color: white; text-decoration: none; padding: 0.5rem 1rem; background: rgba(255,255,255,0.2); border-radius: 6px;">
          üè† Dashboard
        </a>
        <button onclick="logout()"
          style="background: #e53e3e; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer;">
          üö™ ƒêƒÉng xu·∫•t
        </button>
      </div>
    </div>
  </header>

  <div class="admin-container">
    <div id="statusMessage" class="status-message"></div>

    <form class="editor-form" id="newsForm">
      <!-- Article Metadata -->
      <div class="form-section">
        <h3>üìã Th√¥ng Tin B√†i Vi·∫øt</h3>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="title">Ti√™u ƒë·ªÅ b√†i vi·∫øt *</label>
            <input type="text" id="title" name="title" class="form-input" required
              placeholder="Nh·∫≠p ti√™u ƒë·ªÅ b√†i vi·∫øt...">
          </div>

          <div class="form-group full-width">
            <label for="description">M√¥ t·∫£ ng·∫Øn (SEO Description) *</label>
            <textarea id="description" name="description" class="form-input form-textarea" required
              placeholder="M√¥ t·∫£ ng·∫Øn g·ªçn n·ªôi dung b√†i vi·∫øt (150-160 k√Ω t·ª±)..."></textarea>
          </div>

          <div class="form-group">
            <label for="category">Danh m·ª•c</label>
            <select id="category" name="category" class="form-input">
              <option value="TIN T·ª®C">Tin t·ª©c</option>
              <option value="S·ª∞ KI·ªÜN">S·ª± ki·ªán</option>
              <option value="H∆Ø·ªöNG D·∫™N">H∆∞·ªõng d·∫´n</option>
              <option value="KHUY·∫æN M√ÉI">Khuy·∫øn m√£i</option>
            </select>
          </div>

          <div class="form-group">
            <label for="publishDate">Ng√†y xu·∫•t b·∫£n</label>
            <input type="date" id="publishDate" name="publishDate" class="form-input">
          </div>

          <div class="form-group full-width">
            <label for="keywords">T·ª´ kh√≥a SEO (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="keywords" name="keywords" class="form-input"
              placeholder="b·∫£o hi·ªÉm, b·∫£o vi·ªát, ƒë√† n·∫µng...">
          </div>

          <div class="form-group full-width">
            <label for="tags">Tags b√†i vi·∫øt (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="tags" name="tags" class="form-input" placeholder="b·∫£o hi·ªÉm xe, t∆∞ v·∫•n, h∆∞·ªõng d·∫´n...">
          </div>

          <div class="form-group">
            <label for="publishDate">Ng√†y xu·∫•t b·∫£n</label>
            <input type="date" id="publishDate" name="publishDate" class="form-input">
          </div>

          <div class="form-group">
            <label for="featured">
              <input type="checkbox" id="featured" name="featured">
              B√†i vi·∫øt n·ªïi b·∫≠t
            </label>
          </div>

          <div class="form-group full-width">
            <label for="filename">T√™n file (t·ª± ƒë·ªông t·∫°o t·ª´ ti√™u ƒë·ªÅ)</label>
            <input type="text" id="filename" name="filename" class="form-input" readonly
              placeholder="ten-file-se-tu-dong-tao.html">
          </div>
        </div>
      </div>

      <!-- Image Upload -->
      <div class="form-section">
        <h3>üñºÔ∏è Qu·∫£n L√Ω H√¨nh ·∫¢nh</h3>
        <div class="image-upload" id="imageUpload">
          <p>üìÅ K√©o th·∫£ h√¨nh ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn file</p>
          <p style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
            ƒê·ªãnh d·∫°ng: JPG, PNG, WEBP (t·ªëi ƒëa 5MB)<br>
            üí° <strong>Tip:</strong> Click üìù ƒë·ªÉ ch√®n ·∫£nh tr·ª±c ti·∫øp v√†o editor, ho·∫∑c d√πng n√∫t üñºÔ∏è Image trong toolbar
          </p>
          <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
        </div>
        <div id="uploadedImages" class="uploaded-images"></div>
      </div>

      <!-- Content Editor -->
      <div class="form-section">
        <h3>‚úèÔ∏è N·ªôi Dung B√†i Vi·∫øt</h3>
        <div id="editor-status" class="editor-status">
          <span id="editor-status-text">üîÑ ƒêang t·∫£i TinyMCE...</span>
        </div>
        <div class="editor-container">
          <textarea id="contentEditor" name="content"></textarea>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <button type="button" class="btn btn-secondary" onclick="clearForm()">
          üóëÔ∏è X√≥a form
        </button>
        <button type="button" class="btn btn-secondary" onclick="loadArticlesList()">
          üìÇ Load b√†i vi·∫øt
        </button>
        <button type="button" class="btn btn-primary" onclick="previewTemplateHTML()">
          üëÅÔ∏è Preview HTML
        </button>
        <button type="button" class="btn btn-info" onclick="saveDraft()">
          üìë L∆∞u nh√°p
        </button>
        <button type="button" class="btn btn-success" onclick="saveAndPublish()">
          üöÄ L∆∞u v√† Xu·∫•t b·∫£n
        </button>
        <button type="button" class="btn btn-warning" onclick="saveAndDeploy()" style="background: #ff8c00;">
          üöÄ L∆∞u v√† Deploy T·ª± ƒê·ªông
        </button>
        <button type="button" class="btn btn-warning" onclick="manualDeploy()" style="background: #ff8c00;">
          üöÄ Deploy GitHub Pages
        </button>
        <button type="button" class="btn btn-info" onclick="updateNewsPage()"
          style="background: #28a745; color: white;">
          üì∞ C·∫≠p nh·∫≠t Trang Tin T·ª©c
        </button>
        <button type="button" class="btn btn-info" onclick="checkDeployStatus()" style="background: #17a2b8;">
          üìä Ki·ªÉm tra Deploy Status
        </button>
      </div>
    </form>

    <!-- Preview Container -->
    <div id="previewContainer" class="preview-container">
      <div
        style="display: flex; width: 100%; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3>üëÅÔ∏è Xem Tr∆∞·ªõc B√†i Vi·∫øt</h3>
        <button type="button" class="btn btn-secondary" onclick="closePreview()">‚úï ƒê√≥ng</button>
      </div>
      <div id="previewContent"></div>
    </div>
  </div>

  <script>
    let uploadedImages = [];

    // Security: Simple password protection
    const ADMIN_PASSWORD_HASH = 'cf6e93dc9c623c2f10cea0e99bdc01d428d103188c74de8c7d602363cd7c3f5c'; // SHA256 of "secret"
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes

    // Supabase Configuration
    const SUPABASE_CONFIG = {
      // Replace with your Supabase project details
      url: null,
      anonKey: null
    };

    // Initialize Supabase client
    let supabase = null;
    let supabaseInitialized = false;

    async function initializeSupabase() {
      if (supabaseInitialized) return supabase;

      try {
        // Wait for Supabase script to load
        if (!window.supabase) {
          console.log('‚è≥ Waiting for Supabase script to load...');
          await new Promise(resolve => {
            const checkSupabase = () => {
              if (window.supabase) {
                resolve();
              } else {
                setTimeout(checkSupabase, 100);
              }
            };
            checkSupabase();
          });
        }

        // Get configuration from user if not set
        if (!SUPABASE_CONFIG.url || !SUPABASE_CONFIG.anonKey) {
          const storedUrl = localStorage.getItem('supabase_url');
          const storedKey = localStorage.getItem('supabase_anon_key');

          if (storedUrl && storedKey) {
            SUPABASE_CONFIG.url = storedUrl;
            SUPABASE_CONFIG.anonKey = storedKey;
          } else {
            const url = prompt('Nh·∫≠p Supabase URL c·ªßa b·∫°n (ho·∫∑c Enter ƒë·ªÉ d√πng local):');
            const key = url ? prompt('Nh·∫≠p Supabase Anon Key c·ªßa b·∫°n:') : null;

            if (url && key) {
              SUPABASE_CONFIG.url = url;
              SUPABASE_CONFIG.anonKey = key;
              localStorage.setItem('supabase_url', url);
              localStorage.setItem('supabase_anon_key', key);
            }
          }
        }

        if (SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
          supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log('‚úÖ Supabase connected successfully');
          showStatus('ƒê√£ k·∫øt n·ªëi Supabase th√†nh c√¥ng!', 'success');
        } else {
          console.log('‚ö†Ô∏è Supabase not configured, using local mode');
          showStatus('Ch·∫ø ƒë·ªô local - kh√¥ng k·∫øt n·ªëi Supabase', 'info');
        }

        supabaseInitialized = true;
        return supabase;

      } catch (error) {
        console.error('‚ùå Supabase initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o Supabase: ' + error.message, 'error');
        supabaseInitialized = true; // Mark as attempted
        return null;
      }
    }

    function checkAccess() {
      const savedHash = sessionStorage.getItem('admin_access');
      const loginTime = parseInt(sessionStorage.getItem('admin_login_time') || '0');
      const currentTime = Date.now();

      // Check if session expired
      if (currentTime - loginTime > SESSION_TIMEOUT) {
        sessionStorage.removeItem('admin_access');
        sessionStorage.removeItem('admin_login_time');
      }

      if (savedHash !== ADMIN_PASSWORD_HASH) {
        // Redirect to login page instead of prompt
        window.location.href = 'admin-login.html';
        return false;
      }

      document.body.style.display = 'block';

      // Auto-logout after session timeout
      setTimeout(() => {
        alert('‚è∞ Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
        sessionStorage.clear();
        window.location.href = 'admin-login.html';
      }, SESSION_TIMEOUT);

      return true;
    }

    // Hide content initially
    document.body.style.display = 'none';

    // Check access when page loads
    document.addEventListener('DOMContentLoaded', checkAccess);

    // Initialize TinyMCE with error handling
    function initializeTinyMCE() {
      // Check if TinyMCE is loaded
      if (typeof tinymce === 'undefined') {
        console.error('‚ùå TinyMCE not loaded');
        showStatus('L·ªói: TinyMCE kh√¥ng th·ªÉ t·∫£i. Ki·ªÉm tra k·∫øt n·ªëi internet.', 'error');

        // Retry after 2 seconds
        setTimeout(() => {
          if (typeof tinymce !== 'undefined') {
            initializeTinyMCE();
          } else {
            showStatus('‚ùå TinyMCE v·∫´n kh√¥ng th·ªÉ t·∫£i. Vui l√≤ng reload trang.', 'error');
          }
        }, 2000);
        return;
      }

      console.log('‚úÖ TinyMCE loaded, initializing editor...');

      tinymce.init({
        selector: '#contentEditor',
        height: 500,
        menubar: false,
        plugins: [
          'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
          'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
          'insertdatetime', 'media', 'table', 'help', 'wordcount'
        ],
        toolbar: 'undo redo | blocks | bold italic forecolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | removeformat | code preview fullscreen | help',
        content_style: 'body { font-family: -apple-system, BlinkMacSystemFont, San Francisco, Segoe UI, Roboto, Helvetica Neue, sans-serif; font-size: 16px; line-height: 1.6; }',

        // Image upload settings
        images_upload_handler: function (blobInfo, success, failure) {
          // Convert image to base64 for preview (you can implement actual upload here)
          const reader = new FileReader();
          reader.onload = function () {
            success(reader.result);
          };
          reader.readAsDataURL(blobInfo.blob());
        },

        // Allow paste of images
        paste_data_images: true,

        // Image options
        image_advtab: true,
        image_caption: true,
        image_title: true,

        // Success callback
        init_instance_callback: function (editor) {
          console.log('‚úÖ TinyMCE editor initialized successfully');
          updateEditorStatus('‚úÖ Editor ƒë√£ s·∫µn s√†ng!', 'success');
          editor.on('change', function () {
            editor.save();
          });
        },

        // Error handling
        setup: function (editor) {
          editor.on('LoadContent', function () {
            console.log('‚úÖ TinyMCE content loaded');
          });

          editor.on('Error', function (e) {
            console.error('‚ùå TinyMCE Error:', e);
            updateEditorStatus('‚ùå L·ªói editor: ' + e.message, 'error');
          });
        }
      }).catch(function (error) {
        console.error('‚ùå TinyMCE initialization failed:', error);
        updateEditorStatus('‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o editor: ' + error.message, 'error');
      });
    }

    // Initialize TinyMCE when page loads
    document.addEventListener('DOMContentLoaded', function () {
      // Wait a bit for TinyMCE script to load
      setTimeout(initializeTinyMCE, 500);
    });

    // Auto-generate filename from title
    document.getElementById('title').addEventListener('input', function () {
      const title = this.value;
      const filename = generateFilename(title);
      document.getElementById('filename').value = filename;
    });

    // Set default publish date to today
    document.getElementById('publishDate').value = new Date().toISOString().split('T')[0];

    // TinyMCE Helper Functions
    function getTinyMCEEditor() {
      if (typeof tinymce === 'undefined') {
        console.error('TinyMCE not loaded');
        showStatus('Editor ch∆∞a s·∫µn s√†ng. Vui l√≤ng ƒë·ª£i...', 'error');
        return null;
      }

      const editor = tinymce.get('contentEditor');
      if (!editor) {
        console.error('TinyMCE editor not found');
        showStatus('Editor kh√¥ng t√¨m th·∫•y. Vui l√≤ng reload trang.', 'error');
        return null;
      }

      return editor;
    }

    function getTinyMCEContent() {
      const editor = getTinyMCEEditor();
      return editor ? editor.getContent() : '';
    }

    function setTinyMCEContent(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        editor.setContent(content || '');
        console.log('‚úÖ Content set immediately in TinyMCE');
        return true;
      }

      console.warn('‚ö†Ô∏è TinyMCE editor not ready, starting retry sequence...');

      // Multi-stage retry for TinyMCE content loading
      let retryCount = 0;
      const maxRetries = 5;

      const retryInterval = setInterval(() => {
        retryCount++;
        console.log(`üîÑ TinyMCE content retry ${retryCount}/${maxRetries}...`);

        const retryEditor = getTinyMCEEditor();
        if (retryEditor) {
          retryEditor.setContent(content || '');
          console.log('‚úÖ Content loaded into TinyMCE after retry #' + retryCount);
          clearInterval(retryInterval);
          showStatus('‚úÖ N·ªôi dung ƒë√£ ƒë∆∞·ª£c t·∫£i v√†o editor', 'success');
        } else if (retryCount >= maxRetries) {
          console.warn('‚ùå TinyMCE editor still not ready after all retries');
          clearInterval(retryInterval);
          showStatus('‚ö†Ô∏è Editor ch∆∞a s·∫µn s√†ng - vui l√≤ng paste n·ªôi dung th·ªß c√¥ng', 'warning');
        }
      }, 800);

      return false;
    }

    function insertContentToTinyMCE(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        editor.insertContent(content);
        return true;
      }
      return false;
    }

    // Image upload handling
    const imageUpload = document.getElementById('imageUpload');
    const imageInput = document.getElementById('imageInput');
    const uploadedImagesContainer = document.getElementById('uploadedImages');

    imageUpload.addEventListener('click', () => imageInput.click());
    imageUpload.addEventListener('dragover', handleDragOver);
    imageUpload.addEventListener('dragleave', handleDragLeave);
    imageUpload.addEventListener('drop', handleDrop);
    imageInput.addEventListener('change', handleFileSelect);

    function handleDragOver(e) {
      e.preventDefault();
      imageUpload.classList.add('dragover');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      processImages(files);
    }

    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      processImages(files);
    }

    function processImages(files) {
      files.forEach(file => {
        if (file.type.startsWith('image/') && file.size <= 5 * 1024 * 1024) {
          uploadImageToSupabase(file);
        } else {
          if (!file.type.startsWith('image/')) {
            showStatus('L·ªói: ' + file.name + ' kh√¥ng ph·∫£i l√† file h√¨nh ·∫£nh', 'error');
          } else {
            showStatus('L·ªói: ' + file.name + ' qu√° l·ªõn (>5MB)', 'error');
          }
        }
      });
    }

    async function uploadImageToSupabase(file) {
      try {
        // Initialize Supabase if not already done
        const client = await initializeSupabase();

        // Check if Supabase is available and properly initialized
        if (!client || !window.supabase) {
          console.log('üîÑ Supabase not available, using local storage');
          processImageLocally(file);
          return;
        }

        const fileName = Date.now() + '-' + file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const filePath = 'articles/' + fileName;

        showStatus('ƒêang upload ·∫£nh: ' + file.name + '...', 'info');

        // Upload to Supabase Storage with proper error handling
        let uploadResult;
        try {
          uploadResult = await client.storage
            .from('images')
            .upload(filePath, file);
        } catch (storageError) {
          console.error('Storage upload failed:', storageError);
          showStatus('L·ªói k·∫øt n·ªëi storage: ' + storageError.message, 'error');
          processImageLocally(file);
          return;
        }

        const { data: uploadData, error: uploadError } = uploadResult;

        if (uploadError) {
          console.error('Upload error:', uploadError);
          showStatus('L·ªói upload ' + file.name + ': ' + uploadError.message, 'error');
          // Fallback to local processing
          processImageLocally(file);
          return;
        }

        // Get public URL with error handling
        let publicUrlResult;
        try {
          publicUrlResult = client.storage
            .from('images')
            .getPublicUrl(filePath);
        } catch (urlError) {
          console.error('Public URL error:', urlError);
          showStatus('L·ªói t·∫°o URL: ' + urlError.message, 'error');
          processImageLocally(file);
          return;
        }

        const { data: { publicUrl } } = publicUrlResult;

        // Save image metadata to database with error handling
        let dbResult;
        try {
          dbResult = await client
            .from('article_images')
            .insert({
              filename: fileName,
              original_name: file.name,
              file_path: filePath,
              public_url: publicUrl,
              file_size: file.size,
              file_type: file.type
            })
            .select()
            .single();
        } catch (dbError) {
          console.error('Database insert failed:', dbError);
          showStatus('L·ªói l∆∞u v√†o database: ' + dbError.message, 'error');
          // Continue with local storage even if DB fails
        }

        const { data: imageData, error: dbError } = dbResult || { data: null, error: null };

        if (dbError) {
          console.error('Database error:', dbError);
          showStatus('L·ªói l∆∞u metadata ' + file.name + ': ' + dbError.message, 'error');
        }

        // Add to local images array for immediate use
        const imageInfo = {
          id: imageData?.id || Date.now() + Math.random(),
          name: file.name,
          data: publicUrl,
          file: file,
          supabase_id: imageData?.id,
          file_path: filePath
        };
        uploadedImages.push(imageInfo);
        renderUploadedImages();
        showStatus('‚úÖ ƒê√£ upload ·∫£nh: ' + file.name, 'success');

      } catch (error) {
        console.error('Supabase upload error:', error);
        showStatus('L·ªói upload ' + file.name + ': ' + error.message, 'error');
        // Fallback to local processing
        processImageLocally(file);
      }
    }

    function processImageLocally(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        try {
          const imageData = {
            id: Date.now() + Math.random(),
            name: file.name,
            data: e.target.result,
            file: file,
            local: true
          };
          uploadedImages.push(imageData);
          renderUploadedImages();
          showStatus('üì± ƒê√£ l∆∞u ·∫£nh c·ª•c b·ªô: ' + file.name, 'success');
        } catch (error) {
          console.error('Error processing image:', error);
          showStatus('L·ªói khi x·ª≠ l√Ω ·∫£nh: ' + file.name, 'error');
        }
      };

      reader.onerror = function (error) {
        console.error('FileReader error:', error);
        showStatus('L·ªói ƒë·ªçc file: ' + file.name, 'error');
      };

      reader.readAsDataURL(file);
    }

    function renderUploadedImages() {
      uploadedImagesContainer.innerHTML = uploadedImages.map(img =>
        '<div class="uploaded-image">' +
        '<img src="' + img.data + '" alt="' + img.name + '">' +
        '<div class="image-actions">' +
        '<span class="image-type">' + (img.local ? 'üì± C·ª•c b·ªô' : '‚òÅÔ∏è Supabase') + '</span>' +
        '<button type="button" class="image-btn" onclick="insertImageToEditor(' + "'" + img.name + "'" + ', ' + "'" + img.data + "'" + ')" title="Ch√®n v√†o editor">üìù</button>' +
        '<button type="button" class="image-btn" onclick="copyImagePath(' + "'" + img.name + "'" + ')" title="Copy ƒë∆∞·ªùng d·∫´n">üìã</button>' +
        '<button type="button" class="image-btn" onclick="removeImage(' + "'" + img.id + "'" + ')" title="X√≥a ·∫£nh">üóëÔ∏è</button>' +
        '</div>' +
        '</div>'
      ).join('');
    }

    function insertImageToEditor(imageName, imageData) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;
      const altText = imageName.replace(/\.[^/.]+$/, ""); // Remove file extension for alt text

      // Insert image into TinyMCE editor
      if (!insertContentToTinyMCE(
        '<p><img src="' + path + '" alt="' + altText + '" style="width: 100%; max-width: 600px; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></p>'
      )) {
        showStatus('Kh√¥ng th·ªÉ ch√®n ·∫£nh. Editor ch∆∞a s·∫µn s√†ng.', 'error');
        return;
      }

      showStatus('ƒê√£ ch√®n ·∫£nh v√†o editor!', 'success');
    }

    function copyImagePath(imageName) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;

      // Check if clipboard API is available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(path).then(() => {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + path, 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(path);
        });
      } else {
        fallbackCopyToClipboard(path);
      }
    }

    function fallbackCopyToClipboard(text) {
      // Fallback method for copying text
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + text, 'success');
        } else {
          showStatus('Kh√¥ng th·ªÉ copy. ƒê∆∞·ªùng d·∫´n: ' + text, 'error');
        }
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showStatus('ƒê∆∞·ªùng d·∫´n ·∫£nh: ' + text + ' (copy th·ªß c√¥ng)', 'error');
      }

      document.body.removeChild(textArea);
    }

    async function removeImage(imageId) {
      const imageToRemove = uploadedImages.find(img => img.id === imageId);
      if (!imageToRemove) return;

      try {
        // If it's a Supabase image, delete from storage and database
        if (!imageToRemove.local && imageToRemove.file_path) {
          // Initialize Supabase if not already done
          const client = await initializeSupabase();

          if (client) {
            showStatus('ƒêang x√≥a ·∫£nh: ' + imageToRemove.name + '...', 'info');

            // Delete from storage
            const { error: storageError } = await client.storage
              .from('images')
              .remove([imageToRemove.file_path]);

            if (storageError) {
              console.error('Storage deletion error:', storageError);
              showStatus('L·ªói x√≥a file: ' + storageError.message, 'error');
            }

            // Delete from database
            if (imageToRemove.supabase_id) {
              const { error: dbError } = await client
                .from('article_images')
                .delete()
                .eq('id', imageToRemove.supabase_id);

              if (dbError) {
                console.error('Database deletion error:', dbError);
                showStatus('L·ªói x√≥a metadata: ' + dbError.message, 'error');
              }
            }

            showStatus('‚úÖ ƒê√£ x√≥a ·∫£nh: ' + imageToRemove.name, 'success');
          }
        }

        // Remove from local array
        uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        renderUploadedImages();

      } catch (error) {
        console.error('Error removing image:', error);
        showStatus('L·ªói x√≥a ·∫£nh: ' + error.message, 'error');

        // Still remove from local array even if Supabase deletion failed
        uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        renderUploadedImages();
      }
    }

    function generateFilename(title) {
      if (!title) return '';
      return title
        .toLowerCase()
        .replace(/[√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠]/g, 'a')
        .replace(/[√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá]/g, 'e')
        .replace(/[√≠√¨·ªâƒ©·ªã]/g, 'i')
        .replace(/[√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£]/g, 'o')
        .replace(/[√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±]/g, 'u')
        .replace(/[√Ω·ª≥·ª∑·ªπ·ªµ]/g, 'y')
        .replace(/ƒë/g, 'd')
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') + '.html';
    }

    // Template Engine Functions
    let templateEngine = null;

    async function initializeTemplateEngine() {
      if (!templateEngine) {
        templateEngine = new NewsTemplateEngine();
        console.log('‚úÖ Template Engine initialized');
      }
      return templateEngine;
    }

    function prepareTemplateData(formData) {
      const now = new Date();
      const publishDate = formData.publishDate || now.toISOString().split('T')[0];

      return {
        // Basic article data
        title: formData.title,
        content: formData.content,
        category: formData.category || 'Tin t·ª©c',
        filename: formData.filename,
        publishDate: publishDate,
        modifiedDate: now.toISOString().split('T')[0],

        // Meta data for SEO
        meta: {
          description: formData.description || '',
          keywords: formData.keywords || '',
          author: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          robots: 'index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1',
          featured: formData.featured || false,
          image: formData.image || 'https://baohiembaovietdanang.vn/assets/logo.png',
          imageAlt: formData.imageAlt || formData.title
        },

        // Site configuration
        site: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          domain: 'https://baohiembaovietdanang.vn'
        },

        // Tags and related content
        tags: formData.tags ? formData.tags.split(',').map(tag => tag.trim()) : [],

        // Related articles (you can customize this)
        relatedArticles: [
          {
            title: 'B·∫£o hi·ªÉm s·ª©c kh·ªèe B·∫£o Vi·ªát c√≥ n√™n mua? B·∫£ng gi√° 2025',
            summary: 'Chi ti·∫øt v·ªÅ s·∫£n ph·∫©m b·∫£o hi·ªÉm s·ª©c kh·ªèe m·ªõi nh·∫•t t·ª´ B·∫£o Vi·ªát...',
            url: 'bao-hiem-suc-khoe-bao-viet-co-nen-mua-bang-gia-2025.html'
          },
          {
            title: 'B·∫£o hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng - Gi·∫£i ph√°p to√†n di·ªán',
            summary: 'T√¨m hi·ªÉu v·ªÅ c√°c g√≥i b·∫£o hi·ªÉm t·ªëi ∆∞u cho gia ƒë√¨nh...',
            url: 'bao-hiem-bao-viet-danang-giai-phap-toan-dien.html'
          }
        ],

        // Analytics (optional)
        analytics: {
          gtag: 'GA_MEASUREMENT_ID' // Replace with actual GA ID if needed
        },

        // Author info (optional)
        author: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          bio: 'Chuy√™n gia t∆∞ v·∫•n b·∫£o hi·ªÉm h√†ng ƒë·∫ßu t·∫°i ƒê√† N·∫µng'
        }
      };
    }

    async function previewTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang t·∫°o preview...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Open in new window
        const previewWindow = window.open('', '_blank');
        previewWindow.document.open();
        previewWindow.document.write(html);
        previewWindow.document.close();

        showStatus('‚úÖ Preview ƒë√£ m·ªü trong tab m·ªõi!', 'success');

      } catch (error) {
        console.error('Preview error:', error);
        showStatus('‚ùå L·ªói t·∫°o preview: ' + error.message, 'error');
      }
    }

    async function exportTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang xu·∫•t HTML...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Create download
        const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('üíæ ƒê√£ xu·∫•t file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(templateData);

      } catch (error) {
        console.error('Export error:', error);
        showStatus('‚ùå L·ªói xu·∫•t HTML: ' + error.message, 'error');
      }
    }

    function previewArticle() {
      const formData = getFormData();
      if (!formData.title || !formData.content) {
        showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
        return;
      }

      showStatus('Ch·ª©c nƒÉng xem tr∆∞·ªõc ƒë√£ b·ªã x√≥a', 'info');
    }

    function closePreview() {
      document.getElementById('previewContainer').style.display = 'none';
    }

    function getFormData() {
      return {
        title: document.getElementById('title').value,
        description: document.getElementById('description').value,
        category: document.getElementById('category').value,
        publishDate: document.getElementById('publishDate').value,
        keywords: document.getElementById('keywords').value,
        tags: document.getElementById('tags').value,
        featured: document.getElementById('featured').checked,
        filename: document.getElementById('filename').value,
        content: getTinyMCEContent()
        // Note: status will be set automatically by save functions
      };
    }

    function clearForm() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô form?')) {
        document.getElementById('newsForm').reset();
        setTinyMCEContent('');
        uploadedImages = [];
        renderUploadedImages();
        closePreview();
      }
    }

    // Draft/Publish Status Functions
    async function saveDraft() {
      showStatus('üíæ ƒêang l∆∞u nh√°p...', 'info');

      try {
        await saveToSupabaseWithStatus('draft', false); // draft, no deploy
        showStatus('‚úÖ ƒê√£ l∆∞u nh√°p th√†nh c√¥ng!', 'success');
      } catch (error) {
        console.error('Save draft error:', error);
        showStatus('‚ùå L·ªói khi l∆∞u nh√°p: ' + error.message, 'error');
      }
    }

    async function saveAndPublish() {
      showStatus('üìù ƒêang l∆∞u v√† xu·∫•t b·∫£n...', 'info');

      try {
        await saveToSupabaseWithStatus('published', true); // published, auto-deploy
        showStatus('‚úÖ ƒê√£ l∆∞u v√† xu·∫•t b·∫£n th√†nh c√¥ng!', 'success');
      } catch (error) {
        console.error('Save and publish error:', error);
        showStatus('‚ùå L·ªói khi l∆∞u v√† xu·∫•t b·∫£n: ' + error.message, 'error');
      }
    }

    async function saveAndDeploy() {
      showStatus('üöÄ ƒêang l∆∞u v√† deploy t·ª± ƒë·ªông...', 'info');

      try {
        await saveToSupabaseWithStatus('published', true); // published, with auto-deploy
        showStatus('‚úÖ ƒê√£ l∆∞u, xu·∫•t b·∫£n v√† deploy th√†nh c√¥ng!', 'success');
      } catch (error) {
        console.error('Save and deploy error:', error);
        showStatus('‚ùå L·ªói khi l∆∞u v√† deploy: ' + error.message, 'error');
      }
    }

    // Supabase Functions
    async function saveToSupabaseWithStatus(status = 'draft', shouldDeploy = false) {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase. Vui l√≤ng c·∫•u h√¨nh URL v√† API key.', 'error');
        return;
      }

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        // Generate rendered HTML template
        let renderedHTML = null;
        try {
          const engine = await initializeTemplateEngine();
          const templateData = prepareTemplateData(formData);
          renderedHTML = await engine.processTemplate('./templates/news/article.html', templateData);
          console.log('‚úÖ Template rendered successfully for Supabase');
        } catch (templateError) {
          console.warn('‚ö†Ô∏è Could not render template for Supabase:', templateError);
          showStatus('‚ö†Ô∏è L∆∞u kh√¥ng c√≥ template HTML - ch·ªâ l∆∞u d·ªØ li·ªáu th√¥', 'warning');
        }

        // Prepare article data for Supabase with status
        const articleData = {
          title: formData.title,
          description: formData.description,
          content: formData.content,
          category: formData.category,
          keywords: formData.keywords,
          filename: formData.filename,
          published_date: formData.publishDate || new Date().toISOString().split('T')[0],
          is_published: status === 'published',
          status: status // Add status field
        };

        // Add optional fields if they exist in form
        if (formData.tags) {
          articleData.tags = formData.tags;
        }

        if (formData.featured !== undefined) {
          articleData.is_featured = formData.featured;
        }

        if (renderedHTML) {
          articleData.rendered_html = renderedHTML;
          articleData.template_version = '1.0';
        }

        let savedArticle;

        // Check if we're editing an existing article
        if (window.currentEditingId) {
          // Update existing article
          const { data, error } = await client
            .from('articles')
            .update(articleData)
            .eq('id', window.currentEditingId)
            .select()
            .single();

          if (error) throw error;
          savedArticle = data;
          showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t b√†i vi·∫øt th√†nh c√¥ng!', 'success');
        } else {
          // Insert new article
          const { data, error } = await client
            .from('articles')
            .upsert(articleData, {
              onConflict: 'filename',
              ignoreDuplicates: false
            })
            .select()
            .single();

          if (error) throw error;
          savedArticle = data;
          showStatus('‚úÖ ƒê√£ t·∫°o b√†i vi·∫øt m·ªõi th√†nh c√¥ng!', 'success');
        }

        // Associate uploaded Supabase images with this article
        const supabaseImages = uploadedImages.filter(img => !img.local && img.supabase_id);
        if (supabaseImages.length > 0) {
          for (const img of supabaseImages) {
            await client
              .from('article_images')
              .update({ article_id: savedArticle.id })
              .eq('id', img.supabase_id);
          }
          showStatus('‚úÖ ƒê√£ li√™n k·∫øt ' + supabaseImages.length + ' ·∫£nh v·ªõi b√†i vi·∫øt', 'success');
        }

        console.log('Article saved with status:', status, savedArticle);

        // Deploy logic - only deploy if requested and status is published
        if (shouldDeploy && status === 'published') {
          try {
            showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông xu·∫•t b·∫£n GitHub Pages...', 'info');
            await triggerGitHubDeploy(savedArticle);
            showStatus('‚úÖ Xu·∫•t b·∫£n th√†nh c√¥ng!', 'success');
          } catch (deployError) {
            console.warn('‚ö†Ô∏è Auto-deploy failed:', deployError);
            showStatus('‚ö†Ô∏è L∆∞u th√†nh c√¥ng nh∆∞ng t·ª± ƒë·ªông xu·∫•t b·∫£n th·∫•t b·∫°i. C√≥ th·ªÉ xu·∫•t b·∫£n th·ªß c√¥ng sau.', 'warning');
          }
        }

        // Optional: Also create HTML file for published articles
        if (renderedHTML && status === 'published' && confirm('B·∫°n c√≥ mu·ªën t·∫£i file HTML ho√†n ch·ªânh kh√¥ng?')) {
          // Create download with rendered HTML
          const blob = new Blob([renderedHTML], { type: 'text/html;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = formData.filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showStatus('üíæ ƒê√£ t·∫£i file HTML ho√†n ch·ªânh', 'success');
        }

      } catch (error) {
        console.error('Supabase save error:', error);
        showStatus('‚ùå L·ªói l∆∞u v√†o database: ' + error.message, 'error');
        throw error; // Re-throw to be caught by calling function
      }
    }

    // Legacy function for backward compatibility
    async function saveToSupabase() {
      // Default to published status for legacy behavior
      await saveToSupabaseWithStatus('published', true);
    }

    async function loadArticlesList() {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'error');
        return;
      }

      try {
        showStatus('‚è≥ ƒêang t·∫£i danh s√°ch b√†i vi·∫øt...', 'success');

        const { data, error } = await client
          .from('articles')
          .select('id, title, filename, category, published_date, is_published, created_at')
          .order('created_at', { ascending: false });

        if (error) {
          throw error;
        }

        showArticlesList(data);

      } catch (error) {
        console.error('Load articles error:', error);
        showStatus('‚ùå L·ªói t·∫£i danh s√°ch: ' + error.message, 'error');
      }
    }

    function showArticlesList(articles) {
      if (articles.length === 0) {
        showStatus('Ch∆∞a c√≥ b√†i vi·∫øt n√†o trong database', 'error');
        return;
      }

      let listHTML = '<h3>üìã Danh s√°ch b√†i vi·∫øt</h3><ul style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 1rem; margin: 1rem 0;">';

      articles.forEach(article => {
        const publishedBadge = article.is_published ? '‚úÖ' : '‚è≥';
        const dateStr = new Date(article.created_at).toLocaleDateString('vi-VN');

        listHTML +=
          '<li style="margin-bottom: 0.5rem; padding: 0.5rem; border-bottom: 1px solid #eee;">' +
          '<strong>' + publishedBadge + ' ' + article.title + '</strong><br>' +
          '<small>üìÇ ' + article.category + ' | üìÖ ' + dateStr + ' | üìÑ ' + article.filename + '</small><br>' +
          '<button onclick="loadArticle(' + "'" + article.id + "'" + ')" class="btn btn-primary"' +
          ' style="font-size: 0.8rem; padding: 0.25rem 0.5rem; margin-top: 0.25rem;">' +
          'üìù Ch·ªânh s·ª≠a' +
          '</button>' +
          '</li>';
      });

      listHTML += '</ul>';

      // Show in preview container
      document.getElementById('previewContent').innerHTML = listHTML;
      document.getElementById('previewContainer').style.display = 'block';
    }

    async function loadArticle(articleId) {
      // Update URL v·ªõi edit parameter ƒë·ªÉ workflow edit ho·∫°t ƒë·ªông ƒë√∫ng
      const currentUrl = new URL(window.location);
      currentUrl.searchParams.set('edit', articleId);
      window.history.pushState({ edit: articleId }, '', currentUrl.toString());

      // G·ªçi lu√¥n function loadArticleForEdit ƒë√£ t·ªëi ∆∞u thay v√¨ duplicate code
      try {
        await loadArticleForEdit(articleId);

        // Hide preview container sau khi load th√†nh c√¥ng
        closePreview();

        showStatus('‚úÖ ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô ch·ªânh s·ª≠a b√†i vi·∫øt ID: ' + articleId, 'success');

      } catch (error) {
        console.error('Load article error:', error);
        showStatus('‚ùå L·ªói t·∫£i b√†i vi·∫øt: ' + error.message, 'error');
      }
    }

    function downloadHTMLFile(formData) {
      showStatus('Ch·ª©c nƒÉng t·∫£i file ƒë√£ b·ªã x√≥a', 'info');
    }

    // Status functions
    function showStatus(message, type) {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status-message status-' + type;
      statusEl.style.display = 'block';

      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 5000);
    }

    function updateEditorStatus(message, type) {
      const statusEl = document.getElementById('editor-status');
      const textEl = document.getElementById('editor-status-text');

      if (statusEl && textEl) {
        textEl.textContent = message;
        statusEl.className = 'editor-status';
        if (type) {
          statusEl.classList.add(type);
        }
      }
    }

    // Form submission
    document.getElementById('newsForm').addEventListener('submit', function (e) {
      e.preventDefault();

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        showStatus('Ch·ª©c nƒÉng t·∫°o file HTML ƒë√£ b·ªã x√≥a', 'info');
        return;

        // Create download
        const blob = new Blob([articleHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('ƒê√£ t·∫°o th√†nh c√¥ng file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(formData);

      } catch (error) {
        showStatus('C√≥ l·ªói x·∫£y ra khi t·∫°o b√†i vi·∫øt: ' + error.message, 'error');
        console.error(error);
      }
    });

    function generateSitemapEntry(data) {
      const sitemapEntry = '    <url>\n        <loc>https://baohiembaovietdanang.vn/' + data.filename + '</loc>\n        <lastmod>' +
        (data.publishDate || new Date().toISOString().split('T')[0]) + '</lastmod>\n        <changefreq>monthly</changefreq>\n        <priority>0.9</priority>\n    </url>';

      console.log('Sitemap entry to add:', sitemapEntry);

      // Copy to clipboard with error handling
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(sitemapEntry).then(() => {
          showStatus('ƒê√£ copy sitemap entry v√†o clipboard. Th√™m v√†o sitemap.xml!', 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(sitemapEntry);
        });
      } else {
        fallbackCopyToClipboard(sitemapEntry);
      }
    }

    // Initialize application when page loads
    async function initializeApp() {
      try {
        // Check access first
        if (!checkAccess()) {
          console.log('‚ùå Access check failed, redirecting to login');
          return;
        }

        console.log('‚úÖ Access check passed');

        // Initialize Supabase in background (non-blocking)
        initializeSupabase().catch(error => {
          console.log('Supabase initialization failed, using local mode:', error);
        });

        // Initialize Template Engine in background
        initializeTemplateEngine().then(() => {
          console.log('‚úÖ Template Engine ready');
          showStatus('Template Engine ƒë√£ s·∫µn s√†ng!', 'success');
        }).catch(error => {
          console.warn('‚ö†Ô∏è Template Engine initialization failed:', error);
          showStatus('Template Engine kh√¥ng kh·∫£ d·ª•ng - ch·ªâ c√≥ th·ªÉ l∆∞u v√†o DB', 'warning');
        });

        // Set default publish date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('publishDate').value = today;

        // Check if editing existing article
        console.log('üîç Starting URL parameter analysis...');
        const urlParams = new URLSearchParams(window.location.search);
        const editId = urlParams.get('edit');

        console.log('üåê URL Analysis:', {
          fullUrl: window.location.href,
          search: window.location.search,
          editId: editId,
          editIdType: typeof editId,
          editIdLength: editId ? editId.length : 0,
          allParams: Object.fromEntries(urlParams),
          hasEditParam: urlParams.has('edit'),
          rawEditValue: window.location.search.match(/edit=([^&]*)/)?.[1]
        });

        if (editId) {
          console.log('‚úèÔ∏è Edit mode detected with ID:', editId);
          console.log('üîç Current URL:', window.location.href);
          console.log('üîç Edit ID type:', typeof editId, 'Length:', editId.length);
          document.querySelector('.admin-header h1').textContent = '‚úèÔ∏è Ch·ªânh s·ª≠a b√†i vi·∫øt';

          // Wait for both Supabase and TinyMCE to be ready
          console.log('üöÄ Starting waitForSupabaseAndLoadArticle...');
          await waitForSupabaseAndLoadArticle(editId);
        } else {
          console.log('üìù Create new article mode');
        }

        console.log('‚úÖ Admin editor initialized successfully');
        showStatus('Admin interface ƒë√£ s·∫µn s√†ng!', 'success');
      } catch (error) {
        console.error('‚ùå App initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng: ' + error.message, 'error');
      }
    }

    // Wait for Supabase to be ready and load article
    async function waitForSupabaseAndLoadArticle(articleId) {
      console.log('üéØ waitForSupabaseAndLoadArticle called with ID:', articleId);
      let attempts = 0;
      const maxAttempts = 10;

      while (attempts < maxAttempts) {
        try {
          console.log(`üîÑ Attempt ${attempts + 1}/${maxAttempts} to load article...`);

          // Try to get Supabase client
          console.log('üîç Calling initializeSupabase...');
          const client = await initializeSupabase();
          console.log('üîç Supabase client result:', client ? 'SUCCESS' : 'FAILED');

          if (client) {
            console.log('‚úÖ Supabase ready, proceeding to load article...');

            // Also wait for TinyMCE to be available
            if (typeof tinymce !== 'undefined' && tinymce.get('content')) {
              console.log('‚úÖ TinyMCE also ready');
            } else {
              console.log('‚ö†Ô∏è TinyMCE not fully ready yet, but continuing...');
            }

            console.log('üöÄ Calling loadArticleForEdit with ID:', articleId);
            await loadArticleForEdit(articleId);
            console.log('‚úÖ loadArticleForEdit completed successfully');
            return;
          } else {
            console.log('‚ùå Supabase client not ready, retrying...');
          }

          // Wait 500ms before next attempt
          await new Promise(resolve => setTimeout(resolve, 500));
          attempts++;
        } catch (error) {
          console.error(`‚ùå Attempt ${attempts + 1} failed:`, error);
          attempts++;
          if (attempts >= maxAttempts) {
            console.error('‚ùå All attempts failed to load article');
            showErrorModal(
              'Kh√¥ng th·ªÉ t·∫£i b√†i vi·∫øt',
              'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu sau nhi·ªÅu l·∫ßn th·ª≠. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i.'
            );
            break;
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      console.log('‚ùå waitForSupabaseAndLoadArticle finished without success');
    }

    // Load article for editing
    async function loadArticleForEdit(articleId) {
      try {
        console.log('üéØ loadArticleForEdit called with ID:', articleId);
        console.log('üîç Starting to load article for edit. ID type:', typeof articleId, 'Value:', articleId);
        showStatus('‚è≥ ƒêang t·∫£i b√†i vi·∫øt ƒë·ªÉ ch·ªânh s·ª≠a...', 'info');

        console.log('üîó Getting Supabase client...');
        const client = await initializeSupabase();
        if (!client) {
          console.error('‚ùå Supabase client not available');
          showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'error');
          return;
        }

        console.log('‚úÖ Supabase client ready, querying article...');

        // Test query to verify connection
        try {
          console.log('üß™ Running connection test...');
          const testQuery = await client
            .from('articles')
            .select('id, title')
            .limit(1);
          console.log('üîç Supabase connection test result:', testQuery);
        } catch (testError) {
          console.warn('‚ö†Ô∏è Supabase connection test failed:', testError);
        }

        console.log('üì° Executing main query for article ID:', articleId);
        const { data, error } = await client
          .from('articles')
          .select('*')
          .eq('id', articleId)
          .single();

        console.log('üìä Main query result:');
        console.log('- Data:', data);
        console.log('- Error:', error);
        console.log('- Article ID searched:', articleId);

        if (error) {
          console.error('‚ùå Database query error:', error);
          throw error;
        }

        if (!data) {
          console.error('‚ùå No article data returned');
          const errorMessage = `B√†i vi·∫øt v·ªõi ID "${articleId}" kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.`;
          showErrorModal('Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt', errorMessage);
          throw new Error(errorMessage);
        }

        console.log('‚úÖ Article data loaded:', data);
        console.log('üìã Article data details:', {
          id: data.id,
          title: data.title,
          description: data.description,
          category: data.category,
          status: data.status,
          content_length: data.content ? data.content.length : 0
        });

        // Fill form with article data
        console.log('üìù Starting to fill form with article data...');

        try {
          console.log('üîç Validating form elements exist...');
          // Validate form elements exist
          const requiredElements = ['title', 'description', 'category', 'publishDate', 'keywords', 'filename'];
          for (const elementId of requiredElements) {
            const element = document.getElementById(elementId);
            if (!element) {
              console.error(`‚ùå Form element not found: ${elementId}`);
              throw new Error(`Form element kh√¥ng t√¨m th·∫•y: ${elementId}`);
            } else {
              console.log(`‚úÖ Found form element: ${elementId}`);
            }
          }

          console.log('üìù Filling basic form fields...');
          // Fill basic fields
          document.getElementById('title').value = data.title || '';
          console.log('‚úÖ Title filled:', data.title);

          document.getElementById('description').value = data.description || '';
          console.log('‚úÖ Description filled:', data.description);

          document.getElementById('category').value = data.category || 'TIN T·ª®C';
          console.log('‚úÖ Category filled:', data.category);

          document.getElementById('publishDate').value = data.published_date || '';
          console.log('‚úÖ Publish date filled:', data.published_date);

          document.getElementById('keywords').value = data.keywords || '';
          console.log('‚úÖ Keywords filled:', data.keywords);

          document.getElementById('filename').value = data.filename || '';
          console.log('‚úÖ Filename filled:', data.filename);

          // Log article status for reference
          const articleStatus = data.status || (data.is_published ? 'published' : 'draft');
          console.log('‚úÖ Article status loaded:', articleStatus);

          console.log('‚úÖ Basic form fields filled successfully');
        } catch (fillError) {
          console.error('‚ùå Error filling form fields:', fillError);
          throw fillError;
        }

        // Load optional fields if they exist
        try {
          if (data.tags !== undefined) {
            const tagsElement = document.getElementById('tags');
            if (tagsElement) {
              tagsElement.value = data.tags || '';
              console.log('‚úÖ Tags field filled:', data.tags);
            }
          }

          if (data.is_featured !== undefined) {
            const featuredElement = document.getElementById('featured');
            if (featuredElement) {
              featuredElement.checked = data.is_featured || false;
              console.log('‚úÖ Featured field filled:', data.is_featured);
            }
          }
        } catch (optionalError) {
          console.warn('‚ö†Ô∏è Error filling optional fields:', optionalError);
          // Continue execution even if optional fields fail
        }

        // Load content into TinyMCE
        console.log('üìù Loading content into TinyMCE...');
        console.log('üìÑ Content details:', {
          hasContent: !!data.content,
          contentLength: data.content ? data.content.length : 0,
          contentPreview: data.content ? data.content.substring(0, 100) + '...' : 'No content'
        });

        console.log('üîß Calling setTinyMCEContent...');
        setTinyMCEContent(data.content || '');
        console.log('‚úÖ Content loading initiated for TinyMCE');

        console.log('üíæ Storing article ID for future updates...');
        // Store article ID for updating
        window.currentEditingId = articleId;
        console.log('‚úÖ Article ID stored:', window.currentEditingId);

        showStatus('‚úÖ ƒê√£ t·∫£i b√†i vi·∫øt ƒë·ªÉ ch·ªânh s·ª≠a: ' + data.title, 'success');
        console.log('üéâ loadArticleForEdit completed successfully!');

      } catch (error) {
        console.error('‚ùå Error in loadArticleForEdit:', error);
        console.error('‚ùå Error stack:', error.stack);

        // Show error modal for article not found or other critical errors
        if (error.message.includes('kh√¥ng t·ªìn t·∫°i') || error.message.includes('not found')) {
          showErrorModal(
            'Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt',
            `B√†i vi·∫øt v·ªõi ID "${articleId}" kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a. Vui l√≤ng ki·ªÉm tra l·∫°i danh s√°ch b√†i vi·∫øt.`
          );
        } else {
          // For other errors, show modal with general error
          showErrorModal(
            'L·ªói t·∫£i b√†i vi·∫øt',
            `C√≥ l·ªói x·∫£y ra khi t·∫£i b√†i vi·∫øt: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c quay v·ªÅ dashboard.`
          );
        }

        // Also show status for debugging
        showStatus('‚ùå L·ªói t·∫£i b√†i vi·∫øt: ' + error.message, 'error');
      }
    }

    // ÔøΩ UPDATE NEWS PAGE FUNCTION
    async function updateNewsPage() {
      try {
        showStatus('üì∞ ƒêang c·∫≠p nh·∫≠t trang tin t·ª©c...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // L·∫•y t·∫•t c·∫£ b√†i vi·∫øt ƒë√£ published ƒë·ªÉ c·∫≠p nh·∫≠t trang tin t·ª©c
        // S·ª≠ d·ª•ng DISTINCT v√† s·∫Øp x·∫øp ƒë·ªÉ tr√°nh tr√πng l·∫∑p
        const { data: articles, error } = await client
          .from('articles')
          .select('id, title, description, content, category, keywords, filename, published_date, is_published, created_at, updated_at')
          .eq('is_published', true)
          .order('updated_at', { ascending: false }) // ∆Øu ti√™n b√†i vi·∫øt ƒë∆∞·ª£c c·∫≠p nh·∫≠t g·∫ßn nh·∫•t
          .order('created_at', { ascending: false })  // Sau ƒë√≥ theo ng√†y t·∫°o
          .limit(20); // L·∫•y 20 b√†i ƒë·ªÉ c√≥ d·ª± ph√≤ng sau khi deduplicate

        if (error) {
          throw error;
        }

        if (!articles || articles.length === 0) {
          showStatus('‚ö†Ô∏è Kh√¥ng c√≥ b√†i vi·∫øt n√†o ƒë·ªÉ c·∫≠p nh·∫≠t trang tin t·ª©c', 'warning');
          return;
        }

        // Deduplicate theo filename ƒë·ªÉ tr√°nh tr√πng l·∫∑p b√†i vi·∫øt
        const uniqueArticles = [];
        const seenFilenames = new Set();
        const seenIds = new Set();

        for (const article of articles) {
          // Ki·ªÉm tra tr√πng l·∫∑p theo filename v√† id
          if (!seenFilenames.has(article.filename) && !seenIds.has(article.id)) {
            seenFilenames.add(article.filename);
            seenIds.add(article.id);
            uniqueArticles.push(article);
          }
        }

        // Ch·ªâ l·∫•y 15 b√†i sau khi deduplicate
        const finalArticles = uniqueArticles.slice(0, 15);

        showStatus(`üìä ƒê√£ l·ªçc ${finalArticles.length} b√†i vi·∫øt unique t·ª´ ${articles.length} b√†i trong database`, 'info');

        // Call Supabase Edge Function ƒë·ªÉ c·∫≠p nh·∫≠t tin-tuc.html
        const { data, error: updateError } = await client.functions.invoke('update-news-page', {
          body: {
            articles: finalArticles, // S·ª≠ d·ª•ng danh s√°ch ƒë√£ deduplicate
            total_count: articles.length, // G·ª≠i k√®m s·ªë l∆∞·ª£ng g·ªëc ƒë·ªÉ th·ªëng k√™
            unique_count: finalArticles.length,
            trigger_source: 'admin_interface'
          }
        });

        if (updateError) {
          throw updateError;
        }

        if (data && data.success) {
          showStatus(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t trang tin t·ª©c th√†nh c√¥ng! (${finalArticles.length} b√†i vi·∫øt unique)`, 'success');
          console.log('‚úÖ News page updated successfully:', {
            unique_articles: finalArticles.length,
            total_articles: articles.length,
            duplicates_removed: articles.length - finalArticles.length,
            response: data
          });
        } else {
          throw new Error('News page update returned false');
        }

      } catch (error) {
        console.error('‚ùå Update news page failed:', error);

        if (error.message?.includes('not found') || error.message?.includes('404')) {
          showStatus('‚ùå Edge Function "update-news-page" ch∆∞a ƒë∆∞·ª£c deploy!', 'error');
        } else {
          showStatus('‚ùå C·∫≠p nh·∫≠t trang tin t·ª©c th·∫•t b·∫°i: ' + error.message, 'error');
        }

        // Kh√¥ng throw error ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n qu√° tr√¨nh deploy ch√≠nh
        console.warn('‚ö†Ô∏è News page update failed but continuing with main deploy...');
      }
    }

    // ÔøΩüöÄ GITHUB AUTO-DEPLOY FUNCTIONS (VIA SUPABASE EDGE FUNCTION)
    async function triggerGitHubDeploy(article) {
      console.log('üöÄ Triggering GitHub deploy for:', article.filename);

      try {
        showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông deploy GitHub Pages...', 'info');

        // C·∫≠p nh·∫≠t trang tin t·ª©c tr∆∞·ªõc khi deploy b√†i vi·∫øt
        await updateNewsPage();

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // Call Supabase Edge Function ƒë·ªÉ trigger GitHub deploy
        const { data, error } = await client.functions.invoke('deploy-article', {
          body: {
            article_id: article.id,
            trigger_source: 'admin_interface'
          }
        });

        if (error) {
          throw error;
        }

        if (data && data.success) {
          showStatus(`üéâ GitHub deploy ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông! File ${article.filename} s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông.`, 'success');
          console.log('‚úÖ GitHub deploy triggered successfully:', data);

          // Show deploy status
          setTimeout(() => {
            showStatus(`üîç Ki·ªÉm tra GitHub Actions: https://github.com/Liam-and-Son-Group/baoviet-danang/actions`, 'info');
          }, 2000);

        } else {
          throw new Error('Deploy trigger returned false');
        }

      } catch (error) {
        console.error('‚ùå GitHub deploy trigger failed:', error);

        if (error.message?.includes('not found') || error.message?.includes('404')) {
          showStatus('‚ùå Edge Function ch∆∞a ƒë∆∞·ª£c deploy. Vui l√≤ng deploy function "deploy-article" tr∆∞·ªõc!', 'error');
        } else {
          showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
        }

        throw error;
      }
    }    // Manual deploy function cho n√∫t ri√™ng
    async function manualDeploy() {
      try {
        const filename = document.getElementById('filename').value;
        if (!filename) {
          showStatus('‚ùå Vui l√≤ng nh·∫≠p filename tr∆∞·ªõc khi deploy!', 'error');
          return;
        }

        showStatus('üîç ƒêang t√¨m b√†i vi·∫øt ƒë·ªÉ deploy...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // T√¨m b√†i vi·∫øt theo filename
        const { data: articles, error } = await client
          .from('articles')
          .select('*')
          .eq('filename', filename)
          .single();

        if (error || !articles) {
          showStatus('‚ùå Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt v·ªõi filename n√†y trong database!', 'error');
          return;
        }

        await triggerGitHubDeploy(articles);

      } catch (error) {
        console.error('‚ùå Manual deploy failed:', error);
        showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
      }
    }

    // Check deploy status function
    async function checkDeployStatus() {
      try {
        showStatus('üìä ƒêang ki·ªÉm tra deploy logs...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        const { data, error } = await client
          .from('webhook_logs')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(5);

        if (error) {
          throw error;
        }

        console.log('üìä Recent deploy logs:', data);

        const recentLogs = data.map(log => {
          const payload = log.payload?.client_payload || {};
          const time = new Date(log.created_at).toLocaleString('vi-VN');
          return `[${time}] ${payload.article_filename || 'Unknown'} - ${log.status}`;
        }).join('\n');

        showStatus(`üìä Deploy logs (5 g·∫ßn nh·∫•t):\n${recentLogs}`, 'info');

      } catch (error) {
        console.error('‚ùå Check deploy status failed:', error);
        showStatus('‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra deploy status: ' + error.message, 'error');
      }
    }

    window.triggerGitHubDeploy = triggerGitHubDeploy;
    window.manualDeploy = manualDeploy;
    window.checkDeployStatus = checkDeployStatus;
    window.updateNewsPage = updateNewsPage;

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeApp);

    // Logout function
    // Error Modal Functions
    function showErrorModal(title, message) {
      const modal = document.getElementById('errorModal');
      const titleEl = modal.querySelector('.error-modal-title');
      const messageEl = document.getElementById('errorModalMessage');

      if (title) titleEl.textContent = title;
      if (message) messageEl.textContent = message;

      modal.classList.add('show');
      console.log('üö® Error modal displayed:', title, message);

      // Add ESC key listener
      document.addEventListener('keydown', handleModalEscape);
    }

    function hideErrorModal() {
      const modal = document.getElementById('errorModal');
      modal.classList.remove('show');
      document.removeEventListener('keydown', handleModalEscape);
    }

    function handleModalEscape(event) {
      if (event.key === 'Escape') {
        hideErrorModal();
      }
    }

    function handleModalBackdropClick(event) {
      if (event.target === event.currentTarget) {
        hideErrorModal();
      }
    }

    function goBackToDashboard() {
      console.log('üè† Redirecting to dashboard...');
      window.location.href = 'admin-dashboard.html';
    }

    // Debug function - call from browser console to test loading a specific article
    window.debugLoadArticle = function (articleId) {
      console.log('üß™ DEBUG: Testing article loading for ID:', articleId);
      loadArticleForEdit(articleId).catch(error => {
        console.error('üß™ DEBUG: Article loading failed:', error);
      });
    };

    function logout() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒëƒÉng xu·∫•t?')) {
        sessionStorage.clear();
        window.location.href = 'admin-login.html';
      }
    }

  </script>

  <!-- Error Modal -->
  <div id="errorModal" class="error-modal" onclick="handleModalBackdropClick(event)">
    <div class="error-modal-content" onclick="event.stopPropagation()">
      <div class="error-modal-icon">‚ùå</div>
      <div class="error-modal-title">Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt</div>
      <div class="error-modal-message" id="errorModalMessage">
        B√†i vi·∫øt v·ªõi ID ƒë∆∞·ª£c y√™u c·∫ßu kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.
      </div>
      <button class="error-modal-button" onclick="goBackToDashboard()">
        üè† Quay v·ªÅ Dashboard
      </button>
    </div>
  </div>

</body>

</html>