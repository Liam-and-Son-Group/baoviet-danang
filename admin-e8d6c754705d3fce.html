<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - T·∫°o B√†i Vi·∫øt M·ªõi | B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng</title>
  <meta name="robots" content="noindex, nofollow">

  <!-- TinyMCE with Domain-Restricted API Key -->
  <script src="https://cdn.tiny.cloud/1/pnjrxidpb2mr61lce6gwowjzx0yxonun8dz02n46fu0ewe84/tinymce/6/tinymce.min.js"
    referrerpolicy="origin" onerror="handleTinyMCELoadError()"></script>

  <!-- Fallback TinyMCE CDN -->
  <script>
    function handleTinyMCELoadError() {
      console.log('‚ö†Ô∏è Primary TinyMCE CDN failed, trying fallback...');
      updateEditorStatus('‚ö†Ô∏è ƒêang th·ª≠ CDN d·ª± ph√≤ng...', 'error');

      const fallbackScript = document.createElement('script');
      fallbackScript.src = 'https://cdn.jsdelivr.net/npm/tinymce@6/tinymce.min.js';
      fallbackScript.onerror = function () {
        console.error('‚ùå All TinyMCE CDNs failed');
        updateEditorStatus('‚ùå T·∫•t c·∫£ CDN th·∫•t b·∫°i. Ki·ªÉm tra internet v√† reload.', 'error');
      };
      fallbackScript.onload = function () {
        console.log('‚úÖ Fallback TinyMCE loaded successfully');
        updateEditorStatus('üîÑ ƒêang kh·ªüi t·∫°o editor...', '');
      };
      document.head.appendChild(fallbackScript);
    }
  </script>

  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- News Template Engine -->
  <script src="/news-template-engine.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f8fafc;
      color: #1a202c;
      line-height: 1.6;
    }

    .admin-header {
      background: #2d3748;
      color: white;
      padding: 1rem 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .admin-header h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .admin-container {
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    .editor-form {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }

    .form-section {
      margin-bottom: 2rem;
    }

    .form-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    .form-group label {
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #4a5568;
    }

    .form-input {
      padding: 0.75rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: #3182ce;
      box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }

    .editor-container {
      margin: 2rem 0;
    }

    .editor-status {
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
      background-color: #f7fafc;
      border: 1px solid #e2e8f0;
      color: #4a5568;
    }

    .editor-status.success {
      background-color: #f0fff4;
      border-color: #9ae6b4;
      color: #2f855a;
    }

    .editor-status.error {
      background-color: #fed7d7;
      border-color: #fc8181;
      color: #c53030;
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid #e2e8f0;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: #3182ce;
      color: white;
    }

    .btn-primary:hover {
      background: #2c5aa0;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-secondary:hover {
      background: #cbd5e0;
    }

    .btn-success {
      background: #38a169;
      color: white;
    }

    .btn-success:hover {
      background: #2f855a;
    }

    .preview-container {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 2rem;
      margin-top: 2rem;
      display: none;
    }

    .preview-meta {
      background: #f7fafc;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .image-upload {
      border: 2px dashed #cbd5e0;
      border-radius: 6px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .image-upload:hover {
      border-color: #3182ce;
    }

    .image-upload.dragover {
      border-color: #3182ce;
      background: #ebf8ff;
    }

    .uploaded-images {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .uploaded-image {
      position: relative;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #e2e8f0;
    }

    .uploaded-image img {
      width: 100%;
      height: 100px;
      object-fit: cover;
      display: block;
    }

    .image-actions {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .image-type {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border-radius: 3px;
      padding: 0.125rem 0.375rem;
      font-size: 0.7rem;
      font-weight: 500;
      text-align: center;
      white-space: nowrap;
    }

    .image-btn {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .status-message {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }

    .status-success {
      background: #f0fff4;
      color: #22543d;
      border: 1px solid #c6f6d5;
    }

    .status-error {
      background: #fff5f5;
      color: #742a2a;
      border: 1px solid #fed7d7;
    }

    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .action-buttons {
        flex-direction: column;
      }

      .admin-container {
        padding: 0 0.5rem;
      }
    }
  </style>
</head>

<body>
  <header class="admin-header">
    <h1>üìù Admin Panel - T·∫°o B√†i Vi·∫øt M·ªõi</h1>
  </header>

  <div class="admin-container">
    <div id="statusMessage" class="status-message"></div>

    <form class="editor-form" id="newsForm">
      <!-- Article Metadata -->
      <div class="form-section">
        <h3>üìã Th√¥ng Tin B√†i Vi·∫øt</h3>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="title">Ti√™u ƒë·ªÅ b√†i vi·∫øt *</label>
            <input type="text" id="title" name="title" class="form-input" required
              placeholder="Nh·∫≠p ti√™u ƒë·ªÅ b√†i vi·∫øt...">
          </div>

          <div class="form-group full-width">
            <label for="description">M√¥ t·∫£ ng·∫Øn (SEO Description) *</label>
            <textarea id="description" name="description" class="form-input form-textarea" required
              placeholder="M√¥ t·∫£ ng·∫Øn g·ªçn n·ªôi dung b√†i vi·∫øt (150-160 k√Ω t·ª±)..."></textarea>
          </div>

          <div class="form-group">
            <label for="category">Danh m·ª•c</label>
            <select id="category" name="category" class="form-input">
              <option value="TIN T·ª®C">Tin t·ª©c</option>
              <option value="S·ª∞ KI·ªÜN">S·ª± ki·ªán</option>
              <option value="H∆Ø·ªöNG D·∫™N">H∆∞·ªõng d·∫´n</option>
              <option value="KHUY·∫æN M√ÉI">Khuy·∫øn m√£i</option>
            </select>
          </div>

          <div class="form-group">
            <label for="publishDate">Ng√†y xu·∫•t b·∫£n</label>
            <input type="date" id="publishDate" name="publishDate" class="form-input">
          </div>

          <div class="form-group full-width">
            <label for="keywords">T·ª´ kh√≥a SEO (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="keywords" name="keywords" class="form-input"
              placeholder="b·∫£o hi·ªÉm, b·∫£o vi·ªát, ƒë√† n·∫µng...">
          </div>

          <div class="form-group full-width">
            <label for="tags">Tags b√†i vi·∫øt (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="tags" name="tags" class="form-input" placeholder="b·∫£o hi·ªÉm xe, t∆∞ v·∫•n, h∆∞·ªõng d·∫´n...">
          </div>

          <div class="form-group">
            <label for="publishDate">Ng√†y xu·∫•t b·∫£n</label>
            <input type="date" id="publishDate" name="publishDate" class="form-input">
          </div>

          <div class="form-group">
            <label for="featured">
              <input type="checkbox" id="featured" name="featured">
              B√†i vi·∫øt n·ªïi b·∫≠t
            </label>
          </div>

          <div class="form-group full-width">
            <label for="filename">T√™n file (t·ª± ƒë·ªông t·∫°o t·ª´ ti√™u ƒë·ªÅ)</label>
            <input type="text" id="filename" name="filename" class="form-input" readonly
              placeholder="ten-file-se-tu-dong-tao.html">
          </div>
        </div>
      </div>

      <!-- Image Upload -->
      <div class="form-section">
        <h3>üñºÔ∏è Qu·∫£n L√Ω H√¨nh ·∫¢nh</h3>
        <div class="image-upload" id="imageUpload">
          <p>üìÅ K√©o th·∫£ h√¨nh ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn file</p>
          <p style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
            ƒê·ªãnh d·∫°ng: JPG, PNG, WEBP (t·ªëi ƒëa 5MB)<br>
            üí° <strong>Tip:</strong> Click üìù ƒë·ªÉ ch√®n ·∫£nh tr·ª±c ti·∫øp v√†o editor, ho·∫∑c d√πng n√∫t üñºÔ∏è Image trong toolbar
          </p>
          <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
        </div>
        <div id="uploadedImages" class="uploaded-images"></div>
      </div>

      <!-- Content Editor -->
      <div class="form-section">
        <h3>‚úèÔ∏è N·ªôi Dung B√†i Vi·∫øt</h3>
        <div id="editor-status" class="editor-status">
          <span id="editor-status-text">üîÑ ƒêang t·∫£i TinyMCE...</span>
        </div>
        <div class="editor-container">
          <textarea id="contentEditor" name="content"></textarea>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <button type="button" class="btn btn-secondary" onclick="clearForm()">
          üóëÔ∏è X√≥a form
        </button>
        <button type="button" class="btn btn-secondary" onclick="loadArticlesList()">
          üìÇ Load b√†i vi·∫øt
        </button>
        <button type="button" class="btn btn-primary" onclick="previewTemplateHTML()">
          üëÅÔ∏è Preview HTML
        </button>
        <button type="button" class="btn btn-success" onclick="exportTemplateHTML()">
          üìÑ Xu·∫•t HTML
        </button>
        <button type="button" class="btn btn-success" onclick="saveToSupabase()">
          ‚òÅÔ∏è L∆∞u v√†o DB + Auto Deploy
        </button>
        <button type="button" class="btn btn-warning" onclick="manualDeploy()" style="background: #ff8c00;">
          üöÄ Deploy GitHub Pages
        </button>
        <button type="button" class="btn btn-info" onclick="checkDeployStatus()" style="background: #17a2b8;">
          üìä Ki·ªÉm tra Deploy Status
        </button>
      </div>
    </form>

    <!-- Preview Container -->
    <div id="previewContainer" class="preview-container">
      <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 1rem;">
        <h3>üëÅÔ∏è Xem Tr∆∞·ªõc B√†i Vi·∫øt</h3>
        <button type="button" class="btn btn-secondary" onclick="closePreview()">‚úï ƒê√≥ng</button>
      </div>
      <div id="previewContent"></div>
    </div>
  </div>

  <script>
    let uploadedImages = [];

    // Security: Simple password protection
    const ADMIN_PASSWORD_HASH = 'cf6e93dc9c623c2f10cea0e99bdc01d428d103188c74de8c7d602363cd7c3f5c'; // SHA256 of "secret"
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes

    // Supabase Configuration
    const SUPABASE_CONFIG = {
      // Replace with your Supabase project details
      url: null,
      anonKey: null
    };

    // Initialize Supabase client
    let supabase = null;
    let supabaseInitialized = false;

    async function initializeSupabase() {
      if (supabaseInitialized) return supabase;

      try {
        // Wait for Supabase script to load
        if (!window.supabase) {
          console.log('‚è≥ Waiting for Supabase script to load...');
          await new Promise(resolve => {
            const checkSupabase = () => {
              if (window.supabase) {
                resolve();
              } else {
                setTimeout(checkSupabase, 100);
              }
            };
            checkSupabase();
          });
        }

        // Get configuration from user if not set
        if (!SUPABASE_CONFIG.url || !SUPABASE_CONFIG.anonKey) {
          const storedUrl = localStorage.getItem('supabase_url');
          const storedKey = localStorage.getItem('supabase_anon_key');

          if (storedUrl && storedKey) {
            SUPABASE_CONFIG.url = storedUrl;
            SUPABASE_CONFIG.anonKey = storedKey;
          } else {
            const url = prompt('Nh·∫≠p Supabase URL c·ªßa b·∫°n (ho·∫∑c Enter ƒë·ªÉ d√πng local):');
            const key = url ? prompt('Nh·∫≠p Supabase Anon Key c·ªßa b·∫°n:') : null;

            if (url && key) {
              SUPABASE_CONFIG.url = url;
              SUPABASE_CONFIG.anonKey = key;
              localStorage.setItem('supabase_url', url);
              localStorage.setItem('supabase_anon_key', key);
            }
          }
        }

        if (SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
          supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log('‚úÖ Supabase connected successfully');
          showStatus('ƒê√£ k·∫øt n·ªëi Supabase th√†nh c√¥ng!', 'success');
        } else {
          console.log('‚ö†Ô∏è Supabase not configured, using local mode');
          showStatus('Ch·∫ø ƒë·ªô local - kh√¥ng k·∫øt n·ªëi Supabase', 'info');
        }

        supabaseInitialized = true;
        return supabase;

      } catch (error) {
        console.error('‚ùå Supabase initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o Supabase: ' + error.message, 'error');
        supabaseInitialized = true; // Mark as attempted
        return null;
      }
    }

    function checkAccess() {
      const savedHash = sessionStorage.getItem('admin_access');
      const loginTime = parseInt(sessionStorage.getItem('admin_login_time') || '0');
      const currentTime = Date.now();

      // Check if session expired
      if (currentTime - loginTime > SESSION_TIMEOUT) {
        sessionStorage.removeItem('admin_access');
        sessionStorage.removeItem('admin_login_time');
      }

      if (savedHash !== ADMIN_PASSWORD_HASH) {
        const password = prompt('üîê Nh·∫≠p m·∫≠t kh·∫©u admin ƒë·ªÉ truy c·∫≠p:');
        if (!password) {
          window.location.href = '/';
          return false;
        }

        // Simple hash check (use a proper hash for production)
        crypto.subtle.digest('SHA-256', new TextEncoder().encode(password))
          .then(hashBuffer => {
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            if (hashHex === ADMIN_PASSWORD_HASH) {
              sessionStorage.setItem('admin_access', hashHex);
              sessionStorage.setItem('admin_login_time', Date.now().toString());
              document.body.style.display = 'block';

              // Auto-logout after session timeout
              setTimeout(() => {
                alert('‚è∞ Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                sessionStorage.clear();
                window.location.reload();
              }, SESSION_TIMEOUT);
            } else {
              alert('‚ùå M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!');
              window.location.href = '/';
            }
          });
        return false;
      }

      document.body.style.display = 'block';
      return true;
    }

    // Hide content initially
    document.body.style.display = 'none';

    // Check access when page loads
    document.addEventListener('DOMContentLoaded', checkAccess);

    // Initialize TinyMCE with error handling
    function initializeTinyMCE() {
      // Check if TinyMCE is loaded
      if (typeof tinymce === 'undefined') {
        console.error('‚ùå TinyMCE not loaded');
        showStatus('L·ªói: TinyMCE kh√¥ng th·ªÉ t·∫£i. Ki·ªÉm tra k·∫øt n·ªëi internet.', 'error');

        // Retry after 2 seconds
        setTimeout(() => {
          if (typeof tinymce !== 'undefined') {
            initializeTinyMCE();
          } else {
            showStatus('‚ùå TinyMCE v·∫´n kh√¥ng th·ªÉ t·∫£i. Vui l√≤ng reload trang.', 'error');
          }
        }, 2000);
        return;
      }

      console.log('‚úÖ TinyMCE loaded, initializing editor...');

      tinymce.init({
        selector: '#contentEditor',
        height: 500,
        menubar: false,
        plugins: [
          'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
          'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
          'insertdatetime', 'media', 'table', 'help', 'wordcount'
        ],
        toolbar: 'undo redo | blocks | bold italic forecolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | removeformat | code preview fullscreen | help',
        content_style: 'body { font-family: -apple-system, BlinkMacSystemFont, San Francisco, Segoe UI, Roboto, Helvetica Neue, sans-serif; font-size: 16px; line-height: 1.6; }',

        // Image upload settings
        images_upload_handler: function (blobInfo, success, failure) {
          // Convert image to base64 for preview (you can implement actual upload here)
          const reader = new FileReader();
          reader.onload = function () {
            success(reader.result);
          };
          reader.readAsDataURL(blobInfo.blob());
        },

        // Allow paste of images
        paste_data_images: true,

        // Image options
        image_advtab: true,
        image_caption: true,
        image_title: true,

        // Success callback
        init_instance_callback: function (editor) {
          console.log('‚úÖ TinyMCE editor initialized successfully');
          updateEditorStatus('‚úÖ Editor ƒë√£ s·∫µn s√†ng!', 'success');
          editor.on('change', function () {
            editor.save();
          });
        },

        // Error handling
        setup: function (editor) {
          editor.on('LoadContent', function () {
            console.log('‚úÖ TinyMCE content loaded');
          });

          editor.on('Error', function (e) {
            console.error('‚ùå TinyMCE Error:', e);
            updateEditorStatus('‚ùå L·ªói editor: ' + e.message, 'error');
          });
        }
      }).catch(function (error) {
        console.error('‚ùå TinyMCE initialization failed:', error);
        updateEditorStatus('‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o editor: ' + error.message, 'error');
      });
    }

    // Initialize TinyMCE when page loads
    document.addEventListener('DOMContentLoaded', function () {
      // Wait a bit for TinyMCE script to load
      setTimeout(initializeTinyMCE, 500);
    });

    // Auto-generate filename from title
    document.getElementById('title').addEventListener('input', function () {
      const title = this.value;
      const filename = generateFilename(title);
      document.getElementById('filename').value = filename;
    });

    // Set default publish date to today
    document.getElementById('publishDate').value = new Date().toISOString().split('T')[0];

    // TinyMCE Helper Functions
    function getTinyMCEEditor() {
      if (typeof tinymce === 'undefined') {
        console.error('TinyMCE not loaded');
        showStatus('Editor ch∆∞a s·∫µn s√†ng. Vui l√≤ng ƒë·ª£i...', 'error');
        return null;
      }

      const editor = tinymce.get('contentEditor');
      if (!editor) {
        console.error('TinyMCE editor not found');
        showStatus('Editor kh√¥ng t√¨m th·∫•y. Vui l√≤ng reload trang.', 'error');
        return null;
      }

      return editor;
    }

    function getTinyMCEContent() {
      const editor = getTinyMCEEditor();
      return editor ? editor.getContent() : '';
    }

    function setTinyMCEContent(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        editor.setContent(content || '');
        return true;
      }
      return false;
    }

    function insertContentToTinyMCE(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        editor.insertContent(content);
        return true;
      }
      return false;
    }

    // Image upload handling
    const imageUpload = document.getElementById('imageUpload');
    const imageInput = document.getElementById('imageInput');
    const uploadedImagesContainer = document.getElementById('uploadedImages');

    imageUpload.addEventListener('click', () => imageInput.click());
    imageUpload.addEventListener('dragover', handleDragOver);
    imageUpload.addEventListener('dragleave', handleDragLeave);
    imageUpload.addEventListener('drop', handleDrop);
    imageInput.addEventListener('change', handleFileSelect);

    function handleDragOver(e) {
      e.preventDefault();
      imageUpload.classList.add('dragover');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      processImages(files);
    }

    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      processImages(files);
    }

    function processImages(files) {
      files.forEach(file => {
        if (file.type.startsWith('image/') && file.size <= 5 * 1024 * 1024) {
          uploadImageToSupabase(file);
        } else {
          if (!file.type.startsWith('image/')) {
            showStatus('L·ªói: ' + file.name + ' kh√¥ng ph·∫£i l√† file h√¨nh ·∫£nh', 'error');
          } else {
            showStatus('L·ªói: ' + file.name + ' qu√° l·ªõn (>5MB)', 'error');
          }
        }
      });
    }

    async function uploadImageToSupabase(file) {
      try {
        // Initialize Supabase if not already done
        const client = await initializeSupabase();

        // Check if Supabase is available and properly initialized
        if (!client || !window.supabase) {
          console.log('üîÑ Supabase not available, using local storage');
          processImageLocally(file);
          return;
        }

        const fileName = Date.now() + '-' + file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const filePath = 'articles/' + fileName;

        showStatus('ƒêang upload ·∫£nh: ' + file.name + '...', 'info');

        // Upload to Supabase Storage with proper error handling
        let uploadResult;
        try {
          uploadResult = await client.storage
            .from('images')
            .upload(filePath, file);
        } catch (storageError) {
          console.error('Storage upload failed:', storageError);
          showStatus('L·ªói k·∫øt n·ªëi storage: ' + storageError.message, 'error');
          processImageLocally(file);
          return;
        }

        const { data: uploadData, error: uploadError } = uploadResult;

        if (uploadError) {
          console.error('Upload error:', uploadError);
          showStatus('L·ªói upload ' + file.name + ': ' + uploadError.message, 'error');
          // Fallback to local processing
          processImageLocally(file);
          return;
        }

        // Get public URL with error handling
        let publicUrlResult;
        try {
          publicUrlResult = client.storage
            .from('images')
            .getPublicUrl(filePath);
        } catch (urlError) {
          console.error('Public URL error:', urlError);
          showStatus('L·ªói t·∫°o URL: ' + urlError.message, 'error');
          processImageLocally(file);
          return;
        }

        const { data: { publicUrl } } = publicUrlResult;

        // Save image metadata to database with error handling
        let dbResult;
        try {
          dbResult = await client
            .from('article_images')
            .insert({
              filename: fileName,
              original_name: file.name,
              file_path: filePath,
              public_url: publicUrl,
              file_size: file.size,
              file_type: file.type
            })
            .select()
            .single();
        } catch (dbError) {
          console.error('Database insert failed:', dbError);
          showStatus('L·ªói l∆∞u v√†o database: ' + dbError.message, 'error');
          // Continue with local storage even if DB fails
        }

        const { data: imageData, error: dbError } = dbResult || { data: null, error: null };

        if (dbError) {
          console.error('Database error:', dbError);
          showStatus('L·ªói l∆∞u metadata ' + file.name + ': ' + dbError.message, 'error');
        }

        // Add to local images array for immediate use
        const imageInfo = {
          id: imageData?.id || Date.now() + Math.random(),
          name: file.name,
          data: publicUrl,
          file: file,
          supabase_id: imageData?.id,
          file_path: filePath
        };
        uploadedImages.push(imageInfo);
        renderUploadedImages();
        showStatus('‚úÖ ƒê√£ upload ·∫£nh: ' + file.name, 'success');

      } catch (error) {
        console.error('Supabase upload error:', error);
        showStatus('L·ªói upload ' + file.name + ': ' + error.message, 'error');
        // Fallback to local processing
        processImageLocally(file);
      }
    }

    function processImageLocally(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        try {
          const imageData = {
            id: Date.now() + Math.random(),
            name: file.name,
            data: e.target.result,
            file: file,
            local: true
          };
          uploadedImages.push(imageData);
          renderUploadedImages();
          showStatus('üì± ƒê√£ l∆∞u ·∫£nh c·ª•c b·ªô: ' + file.name, 'success');
        } catch (error) {
          console.error('Error processing image:', error);
          showStatus('L·ªói khi x·ª≠ l√Ω ·∫£nh: ' + file.name, 'error');
        }
      };

      reader.onerror = function (error) {
        console.error('FileReader error:', error);
        showStatus('L·ªói ƒë·ªçc file: ' + file.name, 'error');
      };

      reader.readAsDataURL(file);
    }

    function renderUploadedImages() {
      uploadedImagesContainer.innerHTML = uploadedImages.map(img =>
        '<div class="uploaded-image">' +
        '<img src="' + img.data + '" alt="' + img.name + '">' +
        '<div class="image-actions">' +
        '<span class="image-type">' + (img.local ? 'üì± C·ª•c b·ªô' : '‚òÅÔ∏è Supabase') + '</span>' +
        '<button type="button" class="image-btn" onclick="insertImageToEditor(' + "'" + img.name + "'" + ', ' + "'" + img.data + "'" + ')" title="Ch√®n v√†o editor">üìù</button>' +
        '<button type="button" class="image-btn" onclick="copyImagePath(' + "'" + img.name + "'" + ')" title="Copy ƒë∆∞·ªùng d·∫´n">üìã</button>' +
        '<button type="button" class="image-btn" onclick="removeImage(' + "'" + img.id + "'" + ')" title="X√≥a ·∫£nh">üóëÔ∏è</button>' +
        '</div>' +
        '</div>'
      ).join('');
    }

    function insertImageToEditor(imageName, imageData) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;
      const altText = imageName.replace(/\.[^/.]+$/, ""); // Remove file extension for alt text

      // Insert image into TinyMCE editor
      if (!insertContentToTinyMCE(
        '<p><img src="' + path + '" alt="' + altText + '" style="width: 100%; max-width: 600px; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></p>'
      )) {
        showStatus('Kh√¥ng th·ªÉ ch√®n ·∫£nh. Editor ch∆∞a s·∫µn s√†ng.', 'error');
        return;
      }

      showStatus('ƒê√£ ch√®n ·∫£nh v√†o editor!', 'success');
    }

    function copyImagePath(imageName) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;

      // Check if clipboard API is available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(path).then(() => {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + path, 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(path);
        });
      } else {
        fallbackCopyToClipboard(path);
      }
    }

    function fallbackCopyToClipboard(text) {
      // Fallback method for copying text
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + text, 'success');
        } else {
          showStatus('Kh√¥ng th·ªÉ copy. ƒê∆∞·ªùng d·∫´n: ' + text, 'error');
        }
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showStatus('ƒê∆∞·ªùng d·∫´n ·∫£nh: ' + text + ' (copy th·ªß c√¥ng)', 'error');
      }

      document.body.removeChild(textArea);
    }

    async function removeImage(imageId) {
      const imageToRemove = uploadedImages.find(img => img.id === imageId);
      if (!imageToRemove) return;

      try {
        // If it's a Supabase image, delete from storage and database
        if (!imageToRemove.local && imageToRemove.file_path) {
          // Initialize Supabase if not already done
          const client = await initializeSupabase();

          if (client) {
            showStatus('ƒêang x√≥a ·∫£nh: ' + imageToRemove.name + '...', 'info');

            // Delete from storage
            const { error: storageError } = await client.storage
              .from('images')
              .remove([imageToRemove.file_path]);

            if (storageError) {
              console.error('Storage deletion error:', storageError);
              showStatus('L·ªói x√≥a file: ' + storageError.message, 'error');
            }

            // Delete from database
            if (imageToRemove.supabase_id) {
              const { error: dbError } = await client
                .from('article_images')
                .delete()
                .eq('id', imageToRemove.supabase_id);

              if (dbError) {
                console.error('Database deletion error:', dbError);
                showStatus('L·ªói x√≥a metadata: ' + dbError.message, 'error');
              }
            }

            showStatus('‚úÖ ƒê√£ x√≥a ·∫£nh: ' + imageToRemove.name, 'success');
          }
        }

        // Remove from local array
        uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        renderUploadedImages();

      } catch (error) {
        console.error('Error removing image:', error);
        showStatus('L·ªói x√≥a ·∫£nh: ' + error.message, 'error');

        // Still remove from local array even if Supabase deletion failed
        uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        renderUploadedImages();
      }
    }

    function generateFilename(title) {
      if (!title) return '';
      return title
        .toLowerCase()
        .replace(/[√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠]/g, 'a')
        .replace(/[√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá]/g, 'e')
        .replace(/[√≠√¨·ªâƒ©·ªã]/g, 'i')
        .replace(/[√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£]/g, 'o')
        .replace(/[√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±]/g, 'u')
        .replace(/[√Ω·ª≥·ª∑·ªπ·ªµ]/g, 'y')
        .replace(/ƒë/g, 'd')
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') + '.html';
    }

    // Template Engine Functions
    let templateEngine = null;

    async function initializeTemplateEngine() {
      if (!templateEngine) {
        templateEngine = new NewsTemplateEngine();
        console.log('‚úÖ Template Engine initialized');
      }
      return templateEngine;
    }

    function prepareTemplateData(formData) {
      const now = new Date();
      const publishDate = formData.publishDate || now.toISOString().split('T')[0];

      return {
        // Basic article data
        title: formData.title,
        content: formData.content,
        category: formData.category || 'Tin t·ª©c',
        filename: formData.filename,
        publishDate: publishDate,
        modifiedDate: now.toISOString().split('T')[0],

        // Meta data for SEO
        meta: {
          description: formData.description || '',
          keywords: formData.keywords || '',
          author: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          robots: 'index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1',
          featured: formData.featured || false,
          image: formData.image || 'https://baohiembaovietdanang.vn/assets/logo.png',
          imageAlt: formData.imageAlt || formData.title
        },

        // Site configuration
        site: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          domain: 'https://baohiembaovietdanang.vn'
        },

        // Tags and related content
        tags: formData.tags ? formData.tags.split(',').map(tag => tag.trim()) : [],

        // Related articles (you can customize this)
        relatedArticles: [
          {
            title: 'B·∫£o hi·ªÉm s·ª©c kh·ªèe B·∫£o Vi·ªát c√≥ n√™n mua? B·∫£ng gi√° 2025',
            summary: 'Chi ti·∫øt v·ªÅ s·∫£n ph·∫©m b·∫£o hi·ªÉm s·ª©c kh·ªèe m·ªõi nh·∫•t t·ª´ B·∫£o Vi·ªát...',
            url: 'bao-hiem-suc-khoe-bao-viet-co-nen-mua-bang-gia-2025.html'
          },
          {
            title: 'B·∫£o hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng - Gi·∫£i ph√°p to√†n di·ªán',
            summary: 'T√¨m hi·ªÉu v·ªÅ c√°c g√≥i b·∫£o hi·ªÉm t·ªëi ∆∞u cho gia ƒë√¨nh...',
            url: 'bao-hiem-bao-viet-danang-giai-phap-toan-dien.html'
          }
        ],

        // Analytics (optional)
        analytics: {
          gtag: 'GA_MEASUREMENT_ID' // Replace with actual GA ID if needed
        },

        // Author info (optional)
        author: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          bio: 'Chuy√™n gia t∆∞ v·∫•n b·∫£o hi·ªÉm h√†ng ƒë·∫ßu t·∫°i ƒê√† N·∫µng'
        }
      };
    }

    async function previewTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang t·∫°o preview...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Open in new window
        const previewWindow = window.open('', '_blank');
        previewWindow.document.open();
        previewWindow.document.write(html);
        previewWindow.document.close();

        showStatus('‚úÖ Preview ƒë√£ m·ªü trong tab m·ªõi!', 'success');

      } catch (error) {
        console.error('Preview error:', error);
        showStatus('‚ùå L·ªói t·∫°o preview: ' + error.message, 'error');
      }
    }

    async function exportTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang xu·∫•t HTML...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Create download
        const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('üíæ ƒê√£ xu·∫•t file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(templateData);

      } catch (error) {
        console.error('Export error:', error);
        showStatus('‚ùå L·ªói xu·∫•t HTML: ' + error.message, 'error');
      }
    }

    function previewArticle() {
      const formData = getFormData();
      if (!formData.title || !formData.content) {
        showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
        return;
      }

      showStatus('Ch·ª©c nƒÉng xem tr∆∞·ªõc ƒë√£ b·ªã x√≥a', 'info');
    }

    function closePreview() {
      document.getElementById('previewContainer').style.display = 'none';
    }

    function getFormData() {
      return {
        title: document.getElementById('title').value,
        description: document.getElementById('description').value,
        category: document.getElementById('category').value,
        publishDate: document.getElementById('publishDate').value,
        keywords: document.getElementById('keywords').value,
        tags: document.getElementById('tags').value,
        featured: document.getElementById('featured').checked,
        filename: document.getElementById('filename').value,
        content: getTinyMCEContent()
      };
    }

    function clearForm() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô form?')) {
        document.getElementById('newsForm').reset();
        setTinyMCEContent('');
        uploadedImages = [];
        renderUploadedImages();
        closePreview();
      }
    }

    // Supabase Functions
    async function saveToSupabase() {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase. Vui l√≤ng c·∫•u h√¨nh URL v√† API key.', 'error');
        return;
      }

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        showStatus('‚è≥ ƒêang l∆∞u b√†i vi·∫øt...', 'info');

        // Generate rendered HTML template
        let renderedHTML = null;
        try {
          const engine = await initializeTemplateEngine();
          const templateData = prepareTemplateData(formData);
          renderedHTML = await engine.processTemplate('./templates/news/article.html', templateData);
          console.log('‚úÖ Template rendered successfully for Supabase');
        } catch (templateError) {
          console.warn('‚ö†Ô∏è Could not render template for Supabase:', templateError);
          showStatus('‚ö†Ô∏è L∆∞u kh√¥ng c√≥ template HTML - ch·ªâ l∆∞u d·ªØ li·ªáu th√¥', 'warning');
        }

        // Prepare article data for Supabase (ch·ªâ d√πng c·ªôt ƒë√£ c√≥)
        const articleData = {
          title: formData.title,
          description: formData.description,
          content: formData.content,
          category: formData.category,
          keywords: formData.keywords,
          filename: formData.filename,
          published_date: formData.publishDate || new Date().toISOString().split('T')[0],
          is_published: false
        };

        // Th√™m c√°c c·ªôt m·ªõi n·∫øu t·ªìn t·∫°i trong database
        // B·∫°n c√≥ th·ªÉ uncomment nh·ªØng d√≤ng n√†y sau khi ƒë√£ t·∫°o c·ªôt trong Supabase

        // if (formData.tags) {
        //   articleData.tags = formData.tags;
        // }

        // if (formData.featured !== undefined) {
        //   articleData.is_featured = formData.featured;
        // }

        // if (renderedHTML) {
        //   articleData.rendered_html = renderedHTML;
        //   articleData.template_version = '1.0';
        // }

        // Insert or update article
        const { data, error } = await client
          .from('articles')
          .upsert(articleData, {
            onConflict: 'filename',
            ignoreDuplicates: false
          })
          .select();

        if (error) {
          throw error;
        }

        const savedArticle = data[0];

        // Associate uploaded Supabase images with this article
        const supabaseImages = uploadedImages.filter(img => !img.local && img.supabase_id);
        if (supabaseImages.length > 0) {
          for (const img of supabaseImages) {
            await client
              .from('article_images')
              .update({ article_id: savedArticle.id })
              .eq('id', img.supabase_id);
          }
          showStatus('‚úÖ ƒê√£ li√™n k·∫øt ' + supabaseImages.length + ' ·∫£nh v·ªõi b√†i vi·∫øt', 'success');
        }

        // Success message with template info
        const templateStatus = renderedHTML ?
          ' (bao g·ªìm HTML template ho√†n ch·ªânh)' :
          ' (ch·ªâ d·ªØ li·ªáu th√¥ - kh√¥ng c√≥ template)';

        showStatus('‚úÖ ƒê√£ l∆∞u b√†i vi·∫øt v√†o database th√†nh c√¥ng!' + templateStatus, 'success');
        console.log('Article saved:', savedArticle);

        if (renderedHTML) {
          console.log('üìÑ Rendered HTML template saved to database');
        }

        // üöÄ AUTO-TRIGGER GITHUB DEPLOY
        try {
          showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông auto-deploy GitHub Pages...', 'info');
          await triggerGitHubDeploy(savedArticle);
        } catch (deployError) {
          console.warn('‚ö†Ô∏è Auto-deploy failed:', deployError);
          showStatus('‚ö†Ô∏è L∆∞u th√†nh c√¥ng nh∆∞ng auto-deploy th·∫•t b·∫°i. C√≥ th·ªÉ deploy th·ªß c√¥ng sau.', 'warning');
        }

        // Optional: Also create HTML file
        if (renderedHTML && confirm('B·∫°n c√≥ mu·ªën t·∫£i file HTML ho√†n ch·ªânh kh√¥ng?')) {
          // Create download with rendered HTML
          const blob = new Blob([renderedHTML], { type: 'text/html;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = formData.filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showStatus('üíæ ƒê√£ t·∫£i file HTML ho√†n ch·ªânh', 'success');
        }

      } catch (error) {
        console.error('Supabase save error:', error);
        showStatus('‚ùå L·ªói l∆∞u v√†o database: ' + error.message, 'error');
      }
    }

    async function loadArticlesList() {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'error');
        return;
      }

      try {
        showStatus('‚è≥ ƒêang t·∫£i danh s√°ch b√†i vi·∫øt...', 'success');

        const { data, error } = await client
          .from('articles')
          .select('id, title, filename, category, published_date, is_published, created_at')
          .order('created_at', { ascending: false });

        if (error) {
          throw error;
        }

        showArticlesList(data);

      } catch (error) {
        console.error('Load articles error:', error);
        showStatus('‚ùå L·ªói t·∫£i danh s√°ch: ' + error.message, 'error');
      }
    }

    function showArticlesList(articles) {
      if (articles.length === 0) {
        showStatus('Ch∆∞a c√≥ b√†i vi·∫øt n√†o trong database', 'error');
        return;
      }

      let listHTML = '<h3>üìã Danh s√°ch b√†i vi·∫øt</h3><ul style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 1rem; margin: 1rem 0;">';

      articles.forEach(article => {
        const publishedBadge = article.is_published ? '‚úÖ' : '‚è≥';
        const dateStr = new Date(article.created_at).toLocaleDateString('vi-VN');

        listHTML +=
          '<li style="margin-bottom: 0.5rem; padding: 0.5rem; border-bottom: 1px solid #eee;">' +
          '<strong>' + publishedBadge + ' ' + article.title + '</strong><br>' +
          '<small>üìÇ ' + article.category + ' | üìÖ ' + dateStr + ' | üìÑ ' + article.filename + '</small><br>' +
          '<button onclick="loadArticle(' + "'" + article.id + "'" + ')" class="btn btn-primary"' +
          ' style="font-size: 0.8rem; padding: 0.25rem 0.5rem; margin-top: 0.25rem;">' +
          'üìù Ch·ªânh s·ª≠a' +
          '</button>' +
          '</li>';
      });

      listHTML += '</ul>';

      // Show in preview container
      document.getElementById('previewContent').innerHTML = listHTML;
      document.getElementById('previewContainer').style.display = 'block';
    }

    async function loadArticle(articleId) {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'error');
        return;
      }

      try {
        showStatus('‚è≥ ƒêang t·∫£i b√†i vi·∫øt...', 'success');

        const { data, error } = await client
          .from('articles')
          .select('*')
          .eq('id', articleId)
          .single();

        if (error) {
          throw error;
        }

        // Fill form with article data (ch·ªâ d√πng c·ªôt ƒë√£ c√≥)
        document.getElementById('title').value = data.title || '';
        document.getElementById('description').value = data.description || '';
        document.getElementById('category').value = data.category || 'TIN T·ª®C';
        document.getElementById('publishDate').value = data.published_date || '';
        document.getElementById('keywords').value = data.keywords || '';
        document.getElementById('filename').value = data.filename || '';

        // Load c√°c field m·ªõi n·∫øu t·ªìn t·∫°i trong database
        if (data.tags !== undefined) {
          document.getElementById('tags').value = data.tags || '';
        }

        if (data.is_featured !== undefined) {
          document.getElementById('featured').checked = data.is_featured || false;
        }

        // Load content into TinyMCE
        if (!setTinyMCEContent(data.content || '')) {
          showStatus('Kh√¥ng th·ªÉ load n·ªôi dung v√†o editor', 'error');
        }

        closePreview();

        // Show info about rendered HTML availability
        const hasRenderedHTML = data.rendered_html && data.rendered_html.trim().length > 0;
        const templateInfo = hasRenderedHTML ?
          ' (c√≥ template HTML ho√†n ch·ªânh)' :
          ' (ch·ªâ c√≥ d·ªØ li·ªáu th√¥)';

        showStatus('‚úÖ ƒê√£ t·∫£i b√†i vi·∫øt: ' + data.title + templateInfo, 'success');

        // Add button to preview rendered HTML if available
        if (hasRenderedHTML) {
          const previewBtn = document.createElement('button');
          previewBtn.textContent = 'üëÅÔ∏è Xem HTML ƒë√£ l∆∞u';
          previewBtn.className = 'btn btn-info';
          previewBtn.style.margin = '10px 0';
          previewBtn.onclick = () => {
            const previewWindow = window.open('', '_blank');
            previewWindow.document.open();
            previewWindow.document.write(data.rendered_html);
            previewWindow.document.close();
          };

          // Add to status area temporarily
          document.getElementById('statusMessage').appendChild(previewBtn);
          setTimeout(() => {
            if (previewBtn.parentNode) {
              previewBtn.parentNode.removeChild(previewBtn);
            }
          }, 10000);
        }

      } catch (error) {
        console.error('Load article error:', error);
        showStatus('‚ùå L·ªói t·∫£i b√†i vi·∫øt: ' + error.message, 'error');
      }
    }

    function downloadHTMLFile(formData) {
      showStatus('Ch·ª©c nƒÉng t·∫£i file ƒë√£ b·ªã x√≥a', 'info');
    }

    // Status functions
    function showStatus(message, type) {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status-message status-' + type;
      statusEl.style.display = 'block';

      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 5000);
    }

    function updateEditorStatus(message, type) {
      const statusEl = document.getElementById('editor-status');
      const textEl = document.getElementById('editor-status-text');

      if (statusEl && textEl) {
        textEl.textContent = message;
        statusEl.className = 'editor-status';
        if (type) {
          statusEl.classList.add(type);
        }
      }
    }

    // Form submission
    document.getElementById('newsForm').addEventListener('submit', function (e) {
      e.preventDefault();

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        showStatus('Ch·ª©c nƒÉng t·∫°o file HTML ƒë√£ b·ªã x√≥a', 'info');
        return;

        // Create download
        const blob = new Blob([articleHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('ƒê√£ t·∫°o th√†nh c√¥ng file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(formData);

      } catch (error) {
        showStatus('C√≥ l·ªói x·∫£y ra khi t·∫°o b√†i vi·∫øt: ' + error.message, 'error');
        console.error(error);
      }
    });

    function generateSitemapEntry(data) {
      const sitemapEntry = '    <url>\n        <loc>https://baohiembaovietdanang.vn/' + data.filename + '</loc>\n        <lastmod>' +
        (data.publishDate || new Date().toISOString().split('T')[0]) + '</lastmod>\n        <changefreq>monthly</changefreq>\n        <priority>0.9</priority>\n    </url>';

      console.log('Sitemap entry to add:', sitemapEntry);

      // Copy to clipboard with error handling
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(sitemapEntry).then(() => {
          showStatus('ƒê√£ copy sitemap entry v√†o clipboard. Th√™m v√†o sitemap.xml!', 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(sitemapEntry);
        });
      } else {
        fallbackCopyToClipboard(sitemapEntry);
      }
    }

    // Initialize application when page loads
    async function initializeApp() {
      try {
        // Check access first
        checkAccess();

        // Initialize Supabase in background (non-blocking)
        initializeSupabase().catch(error => {
          console.log('Supabase initialization failed, using local mode:', error);
        });

        // Initialize Template Engine in background
        initializeTemplateEngine().then(() => {
          console.log('‚úÖ Template Engine ready');
          showStatus('Template Engine ƒë√£ s·∫µn s√†ng!', 'success');
        }).catch(error => {
          console.warn('‚ö†Ô∏è Template Engine initialization failed:', error);
          showStatus('Template Engine kh√¥ng kh·∫£ d·ª•ng - ch·ªâ c√≥ th·ªÉ l∆∞u v√†o DB', 'warning');
        });

        // Set default publish date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('publishDate').value = today;

        console.log('‚úÖ Admin editor initialized successfully');
        showStatus('Admin interface ƒë√£ s·∫µn s√†ng!', 'success');
      } catch (error) {
        console.error('‚ùå App initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng: ' + error.message, 'error');
      }
    }

    // üöÄ GITHUB AUTO-DEPLOY FUNCTIONS (VIA SUPABASE EDGE FUNCTION)
    async function triggerGitHubDeploy(article) {
      console.log('üöÄ Triggering GitHub deploy for:', article.filename);

      try {
        showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông deploy GitHub Pages...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // Call Supabase Edge Function ƒë·ªÉ trigger GitHub deploy
        const { data, error } = await client.functions.invoke('deploy-article', {
          body: {
            article_id: article.id,
            trigger_source: 'admin_interface'
          }
        });

        if (error) {
          throw error;
        }

        if (data && data.success) {
          showStatus(`üéâ GitHub deploy ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông! File ${article.filename} s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông.`, 'success');
          console.log('‚úÖ GitHub deploy triggered successfully:', data);

          // Show deploy status
          setTimeout(() => {
            showStatus(`üîç Ki·ªÉm tra GitHub Actions: https://github.com/Liam-and-Son-Group/baoviet-danang/actions`, 'info');
          }, 2000);

        } else {
          throw new Error('Deploy trigger returned false');
        }

      } catch (error) {
        console.error('‚ùå GitHub deploy trigger failed:', error);

        if (error.message?.includes('not found') || error.message?.includes('404')) {
          showStatus('‚ùå Edge Function ch∆∞a ƒë∆∞·ª£c deploy. Vui l√≤ng deploy function "deploy-article" tr∆∞·ªõc!', 'error');
        } else {
          showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
        }

        throw error;
      }
    }    // Manual deploy function cho n√∫t ri√™ng
    async function manualDeploy() {
      try {
        const filename = document.getElementById('filename').value;
        if (!filename) {
          showStatus('‚ùå Vui l√≤ng nh·∫≠p filename tr∆∞·ªõc khi deploy!', 'error');
          return;
        }

        showStatus('üîç ƒêang t√¨m b√†i vi·∫øt ƒë·ªÉ deploy...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // T√¨m b√†i vi·∫øt theo filename
        const { data: articles, error } = await client
          .from('articles')
          .select('*')
          .eq('filename', filename)
          .single();

        if (error || !articles) {
          showStatus('‚ùå Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt v·ªõi filename n√†y trong database!', 'error');
          return;
        }

        await triggerGitHubDeploy(articles);

      } catch (error) {
        console.error('‚ùå Manual deploy failed:', error);
        showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
      }
    }

    // Check deploy status function
    async function checkDeployStatus() {
      try {
        showStatus('üìä ƒêang ki·ªÉm tra deploy logs...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        const { data, error } = await client
          .from('webhook_logs')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(5);

        if (error) {
          throw error;
        }

        console.log('üìä Recent deploy logs:', data);

        const recentLogs = data.map(log => {
          const payload = log.payload?.client_payload || {};
          const time = new Date(log.created_at).toLocaleString('vi-VN');
          return `[${time}] ${payload.article_filename || 'Unknown'} - ${log.status}`;
        }).join('\n');

        showStatus(`üìä Deploy logs (5 g·∫ßn nh·∫•t):\n${recentLogs}`, 'info');

      } catch (error) {
        console.error('‚ùå Check deploy status failed:', error);
        showStatus('‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra deploy status: ' + error.message, 'error');
      }
    }

    window.triggerGitHubDeploy = triggerGitHubDeploy;
    window.manualDeploy = manualDeploy;
    window.checkDeployStatus = checkDeployStatus;

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeApp);

  </script>
</body>

</html>