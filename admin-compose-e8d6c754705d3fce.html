<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - T·∫°o B√†i Vi·∫øt M·ªõi | B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng</title>
  <meta name="robots" content="noindex, nofollow">

  <!-- TinyMCE with Domain-Restricted API Key -->
  <script src="https://cdn.tiny.cloud/1/pnjrxidpb2mr61lce6gwowjzx0yxonun8dz02n46fu0ewe84/tinymce/6/tinymce.min.js"
    referrerpolicy="origin" onerror="handleTinyMCELoadError()"></script>

  <!-- Fallback TinyMCE CDN -->
  <script>
    function handleTinyMCELoadError() {
      console.log('‚ö†Ô∏è Primary TinyMCE CDN failed, trying fallback...');
      updateEditorStatus('‚ö†Ô∏è ƒêang th·ª≠ CDN d·ª± ph√≤ng...', 'error');

      const fallbackScript = document.createElement('script');
      fallbackScript.src = 'https://cdn.jsdelivr.net/npm/tinymce@6/tinymce.min.js';
      fallbackScript.onerror = function () {
        console.error('‚ùå All TinyMCE CDNs failed');
        updateEditorStatus('‚ùå T·∫•t c·∫£ CDN th·∫•t b·∫°i. Ki·ªÉm tra internet v√† reload.', 'error');
      };
      fallbackScript.onload = function () {
        console.log('‚úÖ Fallback TinyMCE loaded successfully');
        updateEditorStatus('üîÑ ƒêang kh·ªüi t·∫°o editor...', '');
      };
      document.head.appendChild(fallbackScript);
    }
  </script>

  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- News Template Engine -->
  <script src="/news-template-engine.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f8fafc;
      color: #1a202c;
      line-height: 1.6;
    }

    .admin-header {
      background: #2d3748;
      color: white;
      padding: 1rem 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .admin-header h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .admin-container {
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    .editor-form {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }

    .form-section {
      margin-bottom: 2rem;
    }

    .form-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    .form-group label {
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #4a5568;
    }

    .form-input {
      padding: 0.75rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: #3182ce;
      box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }

    .editor-container {
      margin: 2rem 0;
    }

    .editor-status {
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
      background-color: #f7fafc;
      border: 1px solid #e2e8f0;
      color: #4a5568;
    }

    .editor-status.success {
      background-color: #f0fff4;
      border-color: #9ae6b4;
      color: #2f855a;
    }

    .editor-status.error {
      background-color: #fed7d7;
      border-color: #fc8181;
      color: #c53030;
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid #e2e8f0;
    }

    /* Status Indicator Styles */
    .status-indicator {
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
    }

    .status-indicator.draft {
      background-color: #fef3c7;
      color: #92400e;
      border: 1px solid #f59e0b;
    }

    .status-indicator.published {
      background-color: #d1fae5;
      color: #065f46;
      border: 1px solid #10b981;
    }

    /* Action Button Styles */
    .save-draft-btn {
      background: #6b7280;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .save-draft-btn:hover {
      background: #4b5563;
    }

    .save-publish-btn {
      background: #059669;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .save-publish-btn:hover {
      background: #047857;
    }

    .auto-deploy-btn {
      background: #dc2626;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .auto-deploy-btn:hover {
      background: #b91c1c;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: #3182ce;
      color: white;
    }

    .btn-primary:hover {
      background: #2c5aa0;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-secondary:hover {
      background: #cbd5e0;
    }

    .btn-success {
      background: #38a169;
      color: white;
    }

    .btn-success:hover {
      background: #2f855a;
    }

    .preview-container {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 2rem;
      margin-top: 2rem;
      display: none;
    }

    .preview-meta {
      background: #f7fafc;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .image-upload {
      border: 2px dashed #cbd5e0;
      border-radius: 6px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .image-upload:hover {
      border-color: #3182ce;
    }

    .image-upload.dragover {
      border-color: #3182ce;
      background: #ebf8ff;
    }

    .uploaded-images {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .uploaded-image {
      position: relative;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #e2e8f0;
    }

    .uploaded-image img {
      width: 100%;
      height: 100px;
      object-fit: cover;
      display: block;
    }

    .image-actions {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .image-type {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border-radius: 3px;
      padding: 0.125rem 0.375rem;
      font-size: 0.7rem;
      font-weight: 500;
      text-align: center;
      white-space: nowrap;
    }

    .image-btn {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
    }

    /* Feature Image Styles */
    .feature-image-upload {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      overflow: hidden;
    }

    .feature-image-dropzone {
      border: 2px dashed #cbd5e0;
      border-radius: 6px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
      margin: 1rem;
    }

    .feature-image-dropzone:hover {
      border-color: #3182ce;
    }

    .feature-image-dropzone.dragover {
      border-color: #3182ce;
      background: #ebf8ff;
    }

    .feature-image-preview {
      text-align: center;
      padding: 1rem;
      background: #f7fafc;
    }

    .feature-image-preview img {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border-radius: 8px;
    }

    .feature-image-actions {
      margin-top: 1rem;
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }

    .status-message {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }

    .status-success {
      background: #f0fff4;
      color: #22543d;
      border: 1px solid #c6f6d5;
    }

    .status-error {
      background: #fff5f5;
      color: #742a2a;
      border: 1px solid #fed7d7;
    }

    /* Error Modal Styles */
    .error-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .error-modal.show {
      display: flex;
    }

    .error-modal-content {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 90%;
      text-align: center;
      animation: modalSlideIn 0.3s ease-out;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .error-modal-icon {
      font-size: 4rem;
      color: #e53e3e;
      margin-bottom: 1rem;
    }

    .error-modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 1rem;
    }

    .error-modal-message {
      color: #4a5568;
      margin-bottom: 2rem;
      line-height: 1.5;
    }

    .error-modal-button {
      background: linear-gradient(135deg, #0060ae, #0087d2);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 96, 174, 0.3);
    }

    .error-modal-button:hover {
      background: linear-gradient(135deg, #004d8a, #006bb3);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 96, 174, 0.4);
    }

    /* Enhanced Modal System for notifications - Professional Design */
    .notification-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.75);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10001;
      backdrop-filter: blur(8px) saturate(180%);
      -webkit-backdrop-filter: blur(8px) saturate(180%);
      padding: 1rem;
    }

    .notification-modal.show {
      display: flex;
    }

    .notification-modal-content {
      background: #ffffff;
      padding: 2rem 2.5rem;
      border-radius: 12px;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06),
        0 20px 25px -5px rgba(0, 0, 0, 0.1),
        0 10px 10px -5px rgba(0, 0, 0, 0.04);
      max-width: 420px;
      min-width: 300px;
      width: 100%;
      position: relative;
      animation: modalFadeInUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(226, 232, 240, 0.8);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    }

    .notification-modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 24px;
      height: 24px;
      border: none;
      background: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      color: #9ca3af;
      transition: all 0.15s ease-in-out;
    }

    .notification-modal-close:hover {
      background: #f3f4f6;
      color: #6b7280;
    }

    .notification-modal-close:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
    }

    @keyframes modalFadeInUp {
      from {
        opacity: 0;
        transform: translate3d(0, 20px, 0) scale(0.96);
      }

      to {
        opacity: 1;
        transform: translate3d(0, 0, 0) scale(1);
      }
    }

    .notification-modal-icon {
      font-size: 2.5rem;
      margin-bottom: 1rem;
      display: block;
      opacity: 0.9;
    }

    .notification-modal-title {
      font-size: 1.375rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      color: #1f2937;
      line-height: 1.3;
      letter-spacing: -0.025em;
    }

    .notification-modal-message {
      font-size: 0.95rem;
      line-height: 1.5;
      color: #6b7280;
      margin-bottom: 1.75rem;
      font-weight: 400;
    }

    .notification-modal-buttons {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .notification-modal-button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 0.625rem 1.5rem;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease-in-out;
      min-width: 100px;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      letter-spacing: 0.025em;
    }

    .notification-modal-button:hover {
      background: #2563eb;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    }

    .notification-modal-button:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
    }

    .notification-modal-button.primary {
      background: #10b981;
    }

    .notification-modal-button.primary:hover {
      background: #059669;
    }

    .notification-modal-button.secondary {
      background: #6b7280;
      color: white;
    }

    .notification-modal-button.secondary:hover {
      background: #4b5563;
    }

    .notification-modal-button.danger {
      background: #ef4444;
    }

    .notification-modal-button.danger:hover {
      background: #dc2626;
    }

    /* Status-specific styling - Subtle Professional Approach */
    .notification-modal.loading .notification-modal-icon {
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .notification-modal.loading .notification-modal-title {
      color: #1e40af;
    }

    .notification-modal.success .notification-modal-icon {
      color: #10b981;
    }

    .notification-modal.success .notification-modal-title {
      color: #047857;
    }

    .notification-modal.warning .notification-modal-icon {
      color: #f59e0b;
    }

    .notification-modal.warning .notification-modal-title {
      color: #d97706;
    }

    .notification-modal.error .notification-modal-icon {
      color: #ef4444;
    }

    .notification-modal.error .notification-modal-title {
      color: #dc2626;
    }

    .notification-modal.question .notification-modal-icon {
      color: #8b5cf6;
    }

    .notification-modal.question .notification-modal-title {
      color: #7c3aed;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.5;
        transform: scale(1.05);
      }
    }

    /* Mobile responsiveness for notification modal */
    @media (max-width: 640px) {
      .notification-modal {
        padding: 1rem;
      }

      .notification-modal-content {
        padding: 1.5rem 1.25rem;
        margin: 0;
        min-width: 280px;
        max-width: 340px;
      }

      .notification-modal-title {
        font-size: 1.25rem;
      }

      .notification-modal-message {
        font-size: 0.875rem;
        margin-bottom: 1.5rem;
      }

      .notification-modal-buttons {
        flex-direction: column;
        gap: 0.5rem;
      }

      .notification-modal-button {
        width: 100%;
        min-width: auto;
      }
    }

    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .action-buttons {
        flex-direction: column;
      }

      .admin-container {
        padding: 0 0.5rem;
      }

      .error-modal-content {
        padding: 1.5rem;
        margin: 1rem;
      }
    }
  </style>
</head>

<body>
  <header class="admin-header">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h1>üìù So·∫°n th·∫£o b√†i vi·∫øt</h1>
      <div style="display: flex; gap: 1rem; align-items: center;">
        <a href="admin-dashboard.html"
          style="color: white; text-decoration: none; padding: 0.5rem 1rem; background: rgba(255,255,255,0.2); border-radius: 6px;">
          üè† Dashboard
        </a>
        <button onclick="logout()"
          style="background: #e53e3e; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer;">
          üö™ ƒêƒÉng xu·∫•t
        </button>
      </div>
    </div>
  </header>

  <div class="admin-container">
    <div id="statusMessage" class="status-message"></div>

    <form class="editor-form" id="newsForm">
      <!-- Article Metadata -->
      <div class="form-section">
        <h3>üìã Th√¥ng Tin B√†i Vi·∫øt</h3>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="title">Ti√™u ƒë·ªÅ b√†i vi·∫øt *</label>
            <input type="text" id="title" name="title" class="form-input" required
              placeholder="Nh·∫≠p ti√™u ƒë·ªÅ b√†i vi·∫øt...">
          </div>

          <div class="form-group full-width">
            <label for="description">M√¥ t·∫£ ng·∫Øn (SEO Description) *</label>
            <textarea id="description" name="description" class="form-input form-textarea" required
              placeholder="M√¥ t·∫£ ng·∫Øn g·ªçn n·ªôi dung b√†i vi·∫øt (150-160 k√Ω t·ª±)..."></textarea>
          </div>

          <div class="form-group">
            <label for="category">Danh m·ª•c</label>
            <select id="category" name="category" class="form-input">
              <option value="TIN T·ª®C">Tin t·ª©c</option>
              <option value="S·ª∞ KI·ªÜN">S·ª± ki·ªán</option>
              <option value="H∆Ø·ªöNG D·∫™N">H∆∞·ªõng d·∫´n</option>
              <option value="KHUY·∫æN M√ÉI">Khuy·∫øn m√£i</option>
            </select>
          </div>

          <div class="form-group">
            <label for="publishDate">Ng√†y xu·∫•t b·∫£n</label>
            <input type="date" id="publishDate" name="publishDate" class="form-input">
          </div>

          <div class="form-group full-width">
            <label for="keywords">T·ª´ kh√≥a SEO (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="keywords" name="keywords" class="form-input"
              placeholder="b·∫£o hi·ªÉm, b·∫£o vi·ªát, ƒë√† n·∫µng...">
          </div>

          <div class="form-group full-width">
            <label for="tags">Tags b√†i vi·∫øt (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</label>
            <input type="text" id="tags" name="tags" class="form-input" placeholder="b·∫£o hi·ªÉm xe, t∆∞ v·∫•n, h∆∞·ªõng d·∫´n...">
          </div>

          <div class="form-group">
            <label for="featured">
              <input type="checkbox" id="featured" name="featured">
              B√†i vi·∫øt n·ªïi b·∫≠t
            </label>
          </div>

          <div class="form-group full-width">
            <label for="filename">T√™n file (t·ª± ƒë·ªông t·∫°o t·ª´ ti√™u ƒë·ªÅ)</label>
            <input type="text" id="filename" name="filename" class="form-input" readonly
              placeholder="ten-file-se-tu-dong-tao.html">
          </div>
        </div>
      </div>

      <!-- Feature Image Upload -->
      <div class="form-section">
        <h3>üåü ·∫¢nh ƒê·∫°i Di·ªán (Feature Image)</h3>
        <div class="feature-image-upload" id="featureImageUpload">
          <div class="feature-image-preview" id="featureImagePreview" style="display: none;">
            <img id="featureImageImg" src="" alt="Feature Image Preview"
              style="max-width: 100%; max-height: 300px; border-radius: 8px; border: 2px solid #ddd;">
            <div class="feature-image-actions">
              <button type="button" class="btn btn-secondary" onclick="removeFeatureImage()">üóëÔ∏è X√≥a ·∫£nh</button>
              <button type="button" class="btn btn-primary" onclick="changeFeatureImage()">üîÑ Thay ƒë·ªïi</button>
            </div>
          </div>
          <div class="feature-image-dropzone" id="featureImageDropzone">
            <p>üì∏ K√©o th·∫£ ·∫£nh ƒë·∫°i di·ªán v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</p>
            <p style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
              ƒê·ªãnh d·∫°ng: JPG, PNG, WEBP (t·ªëi ƒëa 5MB)<br>
              üí° <strong>Khuy·∫øn ngh·ªã:</strong> K√≠ch th∆∞·ªõc 1200x630px cho SEO t·ªëi ∆∞u
            </p>
            <input type="file" id="featureImageInput" accept="image/*" style="display: none;">
          </div>
        </div>
      </div>

      <!-- Image Upload -->
      <div class="form-section">
        <h3>üñºÔ∏è Qu·∫£n L√Ω H√¨nh ·∫¢nh</h3>
        <div class="image-upload" id="imageUpload">
          <p>üìÅ K√©o th·∫£ h√¨nh ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn file</p>
          <p style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
            ƒê·ªãnh d·∫°ng: JPG, PNG, WEBP (t·ªëi ƒëa 5MB)<br>
            üí° <strong>Tip:</strong> Click üìù ƒë·ªÉ ch√®n ·∫£nh tr·ª±c ti·∫øp v√†o editor, ho·∫∑c d√πng n√∫t üñºÔ∏è Image trong
            toolbar<br>
            üì± <strong>Base64 Mode:</strong> T·∫•t c·∫£ ·∫£nh s·∫Ω ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi sang base64
          </p>
          <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
        </div>
        <div id="uploadedImages" class="uploaded-images"></div>
      </div>

      <!-- Content Editor -->
      <div class="form-section">
        <h3>‚úèÔ∏è N·ªôi Dung B√†i Vi·∫øt</h3>
        <div id="editor-status" class="editor-status">
          <span id="editor-status-text">üîÑ ƒêang t·∫£i TinyMCE...</span>
        </div>
        <div class="editor-container">
          <textarea id="contentEditor" name="content"></textarea>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <button type="button" class="btn btn-secondary" onclick="clearForm()">
          üóëÔ∏è X√≥a form
        </button>
        <button type="button" class="btn btn-secondary" onclick="loadArticlesList()">
          üìÇ Load b√†i vi·∫øt
        </button>
        <!-- <button type="button" class="btn btn-secondary" onclick="configureSupabase()"
          title="C·∫•u h√¨nh Supabase connection">
          ‚öôÔ∏è C·∫•u h√¨nh
        </button>
        <button type="button" class="btn btn-secondary" onclick="testSupabaseConnection()"
          title="Test k·∫øt n·ªëi Supabase">
          üß™ Test k·∫øt n·ªëi
        </button> -->
        <button type="button" class="btn btn-primary" onclick="previewTemplateHTML()">
          üëÅÔ∏è Preview HTML
        </button>
        <button type="button" class="btn btn-info" onclick="saveDraft()">
          üìë L∆∞u nh√°p
        </button>
        <button type="button" class="btn btn-success" onclick="saveAndPublish()">
          üöÄ L∆∞u v√† Xu·∫•t b·∫£n
        </button>
        <!-- <button type="button" class="btn btn-warning" onclick="saveAndDeploy()" style="background: #ff8c00;">
          üöÄ L∆∞u v√† Deploy T·ª± ƒê·ªông
        </button> -->
        <!-- <button type="button" class="btn btn-warning" onclick="manualDeploy()" style="background: #ff8c00;">
          üöÄ Deploy GitHub Pages
        </button>
        <button type="button" class="btn btn-info" onclick="updateNewsPage()"
          style="background: #28a745; color: white;">
          üì∞ C·∫≠p nh·∫≠t Trang Tin T·ª©c
        </button>
        <button type="button" class="btn btn-info" onclick="checkDeployStatus()" style="background: #17a2b8;">
          üìä Ki·ªÉm tra Deploy Status
        </button> -->
      </div>
    </form>

    <!-- Preview Container -->
    <div id="previewContainer" class="preview-container">
      <div
        style="display: flex; width: 100%; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3>üëÅÔ∏è Xem Tr∆∞·ªõc B√†i Vi·∫øt</h3>
        <button type="button" class="btn btn-secondary" onclick="closePreview()">‚úï ƒê√≥ng</button>
      </div>
      <div id="previewContent"></div>
    </div>
  </div>

  <script>
    /*
    ====================================================================
    üîß H∆Ø·ªöNG D·∫™N SETUP SUPABASE STORAGE
    ====================================================================
    
    1. T·∫†O SUPABASE PROJECT:
       - ƒêƒÉng nh·∫≠p v√†o https://supabase.com
       - T·∫°o project m·ªõi ho·∫∑c s·ª≠ d·ª•ng project c√≥ s·∫µn
    
    2. T·∫†O STORAGE BUCKET:
       - V√†o Storage > New bucket
       - T√™n bucket: "images"
       - Ch·ªçn "Public bucket"
    
    3. C·∫§U H√åNH BUCKET POLICIES:
       - V√†o Storage > Policies
       - Th√™m policy cho public read, authenticated insert/update/delete
    
    4. T·∫†O DATABASE TABLES:
       - V√†o SQL Editor
       - Ch·∫°y script t·∫°o b·∫£ng articles v√† article_images
       - Thi·∫øt l·∫≠p RLS policies ph√π h·ª£p
       
       * QUAN TR·ªåNG: RLS (Row Level Security) Policy *
       N·∫øu g·∫∑p l·ªói "new row violates row-level security policy":
       - T·∫Øt RLS: ALTER TABLE article_images DISABLE ROW LEVEL SECURITY;
       - Ho·∫∑c t·∫°o policy cho ph√©p insert/update/delete:
         CREATE POLICY "Enable all access" ON article_images FOR ALL USING (true);
       - H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông fallback khi g·∫∑p l·ªói RLS
    
    5. C·∫§U H√åNH TRONG CODE:
       - Thay ƒë·ªïi SUPABASE_CONFIG.url b√™n d∆∞·ªõi
       - Nh·∫≠p anon key qua UI ho·∫∑c button "‚öôÔ∏è C·∫•u h√¨nh"
    
    6. TEST K·∫æT N·ªêI:
       - S·ª≠ d·ª•ng button "üß™ Test k·∫øt n·ªëi"
       - Ki·ªÉm tra upload ·∫£nh trong TinyMCE editor
    
    ====================================================================
    */
    let uploadedImages = [];
    let featureImage = null; // Store feature image data

    // Security: Simple password protection
    const ADMIN_PASSWORD_HASH = 'cf6e93dc9c623c2f10cea0e99bdc01d428d103188c74de8c7d602363cd7c3f5c'; // SHA256 of "secret"
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes

    // Supabase Configuration
    const SUPABASE_CONFIG = {
      // Supabase project URL (thay th·∫ø b·∫±ng URL project c·ªßa b·∫°n)
      url: 'https://fiaxrsiycswrwucthian.supabase.co', // ‚ö†Ô∏è THAY ƒê·ªîI URL N√ÄY
      anonKey: null // S·∫Ω ƒë∆∞·ª£c nh·∫≠p qua UI
    };

    // Initialize Supabase client
    let supabase = null;
    let supabaseInitialized = false;

    // Configuration function for Supabase
    function configureSupabase() {
      const newKey = prompt('Nh·∫≠p Supabase Anon Key m·ªõi:', SUPABASE_CONFIG.anonKey || '');

      if (newKey && newKey.trim()) {
        SUPABASE_CONFIG.anonKey = newKey.trim();
        localStorage.setItem('supabase_anon_key', newKey.trim());

        // Reset initialization to force reconnection
        supabaseInitialized = false;
        supabase = null;

        showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t Supabase configuration!', 'success');

        // Try to reconnect and test
        testSupabaseConnection();
      }
    }

    // Test Supabase connection
    async function testSupabaseConnection() {
      try {
        showStatus('üß™ ƒêang test k·∫øt n·ªëi Supabase...', 'info');

        const client = await initializeSupabase();
        if (!client) {
          showStatus('‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o Supabase client', 'error');
          return false;
        }

        // Test basic connection with a simple query
        console.log('üîç Testing Supabase connection...');
        const { data, error } = await Promise.race([
          client.from('articles').select('id').limit(1),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Connection timeout')), 10000)
          )
        ]);

        if (error) {
          console.error('‚ùå Supabase connection test failed:', error);
          showStatus('‚ùå Test k·∫øt n·ªëi th·∫•t b·∫°i: ' + error.message, 'error');

          // Show helpful error messages
          if (error.message.includes('JWT')) {
            showStatus('üí° L·ªói JWT - ki·ªÉm tra l·∫°i Anon Key', 'warning');
          } else if (error.message.includes('timeout')) {
            showStatus('üí° Timeout - ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† URL Supabase', 'warning');
          }
          return false;
        }

        console.log('‚úÖ Supabase connection test successful');
        showStatus('‚úÖ K·∫øt n·ªëi Supabase th√†nh c√¥ng! C√≥ th·ªÉ upload ·∫£nh l√™n Storage.', 'success');
        updateSupabaseStatus('‚úÖ Test th√†nh c√¥ng - Supabase ho·∫°t ƒë·ªông t·ªët', 'success');
        return true;

      } catch (error) {
        console.error('‚ùå Connection test error:', error);
        if (error.message.includes('timeout')) {
          showStatus('‚ùå Timeout k·∫øt n·ªëi - ki·ªÉm tra m·∫°ng v√† URL Supabase', 'error');
          updateSupabaseStatus('‚ùå Timeout k·∫øt n·ªëi - ki·ªÉm tra m·∫°ng', 'error');
        } else {
          showStatus('‚ùå L·ªói test k·∫øt n·ªëi: ' + error.message, 'error');
          updateSupabaseStatus('‚ùå L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
        }
        return false;
      }
    } async function initializeSupabase() {
      if (supabaseInitialized) return supabase;

      try {
        // Wait for Supabase script to load
        if (!window.supabase) {
          console.log('‚è≥ Waiting for Supabase script to load...');
          await new Promise(resolve => {
            const checkSupabase = () => {
              if (window.supabase) {
                resolve();
              } else {
                setTimeout(checkSupabase, 100);
              }
            };
            checkSupabase();
          });
        }

        // Get configuration from user if not set
        if (!SUPABASE_CONFIG.anonKey) {
          const storedKey = localStorage.getItem('supabase_anon_key');

          if (storedKey) {
            SUPABASE_CONFIG.anonKey = storedKey;
          } else {
            const key = prompt('Nh·∫≠p Supabase Anon Key c·ªßa b·∫°n:');

            if (key) {
              SUPABASE_CONFIG.anonKey = key;
              localStorage.setItem('supabase_anon_key', key);
            }
          }
        }

        if (SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
          supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log('‚úÖ Supabase connected successfully');
          showStatus('ƒê√£ k·∫øt n·ªëi Supabase th√†nh c√¥ng!', 'success');
          updateSupabaseStatus('‚úÖ Supabase ƒë√£ k·∫øt n·ªëi - c√≥ th·ªÉ upload ·∫£nh l√™n Storage', 'success');
        } else {
          console.log('‚ö†Ô∏è Supabase not configured, using local mode');
          showStatus('Ch·∫ø ƒë·ªô local - kh√¥ng k·∫øt n·ªëi Supabase', 'info');
          updateSupabaseStatus('‚ö†Ô∏è Supabase ch∆∞a c·∫•u h√¨nh - ·∫£nh s·∫Ω l∆∞u d·∫°ng base64', 'warning');
        }

        supabaseInitialized = true;
        return supabase;

      } catch (error) {
        console.error('‚ùå Supabase initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o Supabase: ' + error.message, 'error');
        updateSupabaseStatus('‚ùå L·ªói k·∫øt n·ªëi Supabase: ' + error.message, 'error');
        supabaseInitialized = true; // Mark as attempted
        return null;
      }
    }

    // Update Supabase status indicator
    function updateSupabaseStatus(message, type) {
      const statusEl = document.getElementById('supabaseStatus');
      const textEl = document.getElementById('supabaseStatusText');

      if (statusEl && textEl) {
        textEl.textContent = message;

        // Update styling based on status type
        statusEl.style.background = type === 'success' ? '#d4edda' :
          type === 'warning' ? '#fff3cd' :
            type === 'error' ? '#f8d7da' : '#f8f9fa';
        statusEl.style.borderColor = type === 'success' ? '#c3e6cb' :
          type === 'warning' ? '#ffeaa7' :
            type === 'error' ? '#f5c6cb' : '#dee2e6';
        statusEl.style.color = type === 'success' ? '#155724' :
          type === 'warning' ? '#856404' :
            type === 'error' ? '#721c24' : '#495057';
      }
    }

    function checkAccess() {
      const savedHash = sessionStorage.getItem('admin_access');
      const loginTime = parseInt(sessionStorage.getItem('admin_login_time') || '0');
      const currentTime = Date.now();

      // Check if session expired
      if (currentTime - loginTime > SESSION_TIMEOUT) {
        sessionStorage.removeItem('admin_access');
        sessionStorage.removeItem('admin_login_time');
      }

      if (savedHash !== ADMIN_PASSWORD_HASH) {
        // Redirect to login page instead of prompt
        window.location.href = 'admin-login.html';
        return false;
      }

      document.body.style.display = 'block';

      // Auto-logout after session timeout
      setTimeout(() => {
        alert('‚è∞ Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
        sessionStorage.clear();
        window.location.href = 'admin-login.html';
      }, SESSION_TIMEOUT);

      return true;
    }

    // Hide content initially
    document.body.style.display = 'none';

    // Check access when page loads
    document.addEventListener('DOMContentLoaded', checkAccess);

    // Initialize TinyMCE with error handling
    function initializeTinyMCE() {
      // Check if TinyMCE is loaded
      if (typeof tinymce === 'undefined') {
        console.error('‚ùå TinyMCE not loaded');
        showStatus('L·ªói: TinyMCE kh√¥ng th·ªÉ t·∫£i. Ki·ªÉm tra k·∫øt n·ªëi internet.', 'error');

        // Retry after 2 seconds
        setTimeout(() => {
          if (typeof tinymce !== 'undefined') {
            initializeTinyMCE();
          } else {
            showStatus('‚ùå TinyMCE v·∫´n kh√¥ng th·ªÉ t·∫£i. Vui l√≤ng reload trang.', 'error');
          }
        }, 2000);
        return;
      }

      console.log('‚úÖ TinyMCE loaded, initializing editor...');

      try {
        const initResult = tinymce.init({
          selector: '#contentEditor',
          height: 500,
          menubar: false,
          plugins: [
            'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
            'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
            'insertdatetime', 'media', 'table', 'help', 'wordcount'
          ],
          toolbar: 'undo redo | blocks | bold italic forecolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | removeformat | code preview fullscreen | help',
          content_style: 'body { font-family: -apple-system, BlinkMacSystemFont, San Francisco, Segoe UI, Roboto, Helvetica Neue, sans-serif; font-size: 16px; line-height: 1.6; }',

          // Image upload settings - Supabase Storage mode
          images_upload_handler: async function (blobInfo, success, failure, progress) {
            try {
              console.log('üñºÔ∏è TinyMCE image upload started (Supabase mode):', blobInfo.filename());
              console.log('üîç Callback functions available:', {
                success: typeof success,
                failure: typeof failure,
                progress: typeof progress
              });

              // Show initial progress
              if (progress && typeof progress === 'function') {
                progress(0);
              }

              // Initialize Supabase if not already done
              const client = await initializeSupabase();

              if (!client || !window.supabase) {
                console.warn('‚ö†Ô∏è Supabase not available, falling back to base64');
                showStatus('‚ö†Ô∏è Supabase kh√¥ng kh·∫£ d·ª•ng - s·ª≠ d·ª•ng base64 fallback', 'warning');

                // Fallback to base64 if Supabase not available
                const reader = new FileReader();
                reader.onload = function () {
                  if (typeof success === 'function') {
                    const base64Url = reader.result;
                    console.log('üîÑ Fallback base64 URL:', base64Url.substring(0, 50) + '...');
                    success(base64Url);
                    showStatus('üì± ƒê√£ l∆∞u ·∫£nh d·∫°ng base64 (fallback)', 'info');
                  }
                };
                reader.onerror = function () {
                  if (typeof failure === 'function') {
                    failure('L·ªói ƒë·ªçc file ·∫£nh');
                  }
                };
                reader.readAsDataURL(blobInfo.blob());
                return;
              }

              const file = blobInfo.blob();
              const fileName = Date.now() + '-tinymce-' + blobInfo.filename().replace(/[^a-zA-Z0-9.-]/g, '_');
              const filePath = 'editor/' + fileName;

              // Show progress
              if (progress && typeof progress === 'function') {
                progress(25);
              }

              console.log('‚òÅÔ∏è Uploading to Supabase Storage:', filePath);
              showStatus('‚òÅÔ∏è ƒêang upload ·∫£nh l√™n Supabase Storage: ' + blobInfo.filename(), 'info');

              // Upload to Supabase Storage with timeout
              const uploadPromise = client.storage
                .from('images')
                .upload(filePath, file);

              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Upload timeout after 15 seconds')), 15000);
              });

              const { data: uploadData, error: uploadError } = await Promise.race([
                uploadPromise,
                timeoutPromise
              ]);

              if (uploadError) {
                console.error('TinyMCE Supabase upload error:', uploadError);

                // Auto-fallback to base64 for any upload errors
                console.warn('üîÑ Upload failed, falling back to base64');
                showStatus('‚ö†Ô∏è L·ªói upload Supabase - chuy·ªÉn sang base64 fallback', 'warning');

                const reader = new FileReader();
                reader.onload = function () {
                  if (typeof success === 'function') {
                    const base64Url = reader.result;
                    console.log('üîÑ Upload error fallback base64 URL:', base64Url.substring(0, 50) + '...');
                    success(base64Url);
                    showStatus('üì± ƒê√£ l∆∞u ·∫£nh d·∫°ng base64 (fallback)', 'info');
                  }
                };
                reader.onerror = function () {
                  if (typeof failure === 'function') {
                    failure('L·ªói x·ª≠ l√Ω ·∫£nh fallback');
                  }
                };
                reader.readAsDataURL(blobInfo.blob());
                return;
              }

              // Show progress
              if (progress && typeof progress === 'function') {
                progress(75);
              }

              // Get public URL
              const { data: { publicUrl } } = client.storage
                .from('images')
                .getPublicUrl(filePath);

              console.log('‚úÖ Supabase public URL generated:', publicUrl);
              console.log('üîç Public URL type:', typeof publicUrl);
              console.log('üîç Public URL length:', publicUrl ? publicUrl.length : 'null/undefined');

              // Validate public URL
              if (!publicUrl || publicUrl.trim() === '') {
                console.error('‚ùå Invalid public URL generated:', publicUrl);
                throw new Error('Public URL is empty or invalid');
              }

              // Save image metadata to database (optional - skip if RLS blocks)
              try {
                await client
                  .from('article_images')
                  .insert({
                    article_id: null, // Will be linked later when article is saved
                    filename: fileName,
                    original_name: blobInfo.filename(),
                    storage_path: filePath,
                    file_size: file.size,
                    file_type: file.type
                  });
                console.log('‚úÖ Image metadata saved to database');
              } catch (dbError) {
                console.warn('‚ö†Ô∏è Could not save image metadata:', dbError);

                // Check if it's RLS error
                if (dbError.message && dbError.message.includes('row-level security')) {
                  console.warn('üîí RLS policy blocks image metadata insert - continuing without DB tracking');
                  showStatus('‚ö†Ô∏è Kh√¥ng th·ªÉ l∆∞u th√¥ng tin ·∫£nh v√†o DB (RLS) - ·∫£nh v·∫´n upload th√†nh c√¥ng', 'warning');
                } else if (dbError.statusCode === '403' || dbError.error === 'Unauthorized') {
                  console.warn('üîí Database access denied - continuing without DB tracking');
                  showStatus('‚ö†Ô∏è Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p DB - ·∫£nh v·∫´n upload th√†nh c√¥ng', 'warning');
                } else {
                  console.warn('‚ö†Ô∏è Unexpected database error:', dbError);
                  showStatus('‚ö†Ô∏è L·ªói DB kh√¥ng x√°c ƒë·ªãnh - ·∫£nh v·∫´n upload th√†nh c√¥ng', 'warning');
                }

                // Continue anyway - we have the image uploaded to Storage successfully
                // The image URL will still work even without DB metadata
              }

              // Complete progress
              if (progress && typeof progress === 'function') {
                progress(100);
              }

              console.log('‚úÖ TinyMCE image uploaded successfully to Supabase:', publicUrl);
              showStatus('‚úÖ ƒê√£ upload ·∫£nh l√™n Supabase: ' + blobInfo.filename(), 'success');

              // Return Supabase public URL to TinyMCE
              // TinyMCE will use this as the src attribute of the img tag
              if (typeof success === 'function') {
                // Ensure the URL is valid and properly formatted
                const finalUrl = publicUrl.trim();
                console.log('üéØ Final URL being passed to TinyMCE:', finalUrl);

                // TinyMCE expects just the URL string, not an object
                console.log('‚úÖ Success callback executed successfully');
                return finalUrl;
              } else {
                console.error('‚ùå Success callback not available or not a function');
                console.log('üîç Success callback type:', typeof success);
              }

            } catch (error) {
              console.error('TinyMCE upload error:', error);

              // Check if it's a network/timeout/connection error
              const isNetworkError = error.message.includes('timeout') ||
                error.message.includes('fetch') ||
                error.message.includes('network') ||
                error.message.includes('connection') ||
                error.message.includes('ERR_CONNECTION_TIMED_OUT') ||
                error.name === 'StorageUnknownError';

              if (isNetworkError) {
                console.warn('üîÑ Network/timeout error detected, auto-fallback to base64');
                showStatus('‚ö†Ô∏è Timeout k·∫øt n·ªëi Supabase - t·ª± ƒë·ªông chuy·ªÉn sang base64', 'warning');
              } else {
                console.error('‚ùå Unexpected upload error:', error);
                showStatus('‚ùå L·ªói upload kh√¥ng x√°c ƒë·ªãnh: ' + error.message, 'error');
              }

              // Fallback to base64 on any error
              try {
                const reader = new FileReader();
                reader.onload = function () {
                  if (typeof success === 'function') {
                    const base64Url = reader.result;
                    console.log('üîÑ Final fallback base64 URL:', base64Url.substring(0, 50) + '...');
                    success(base64Url);
                    showStatus('üì± ƒê√£ l∆∞u ·∫£nh d·∫°ng base64 (fallback)', 'info');
                  }
                };
                reader.onerror = function () {
                  if (typeof failure === 'function') {
                    failure('L·ªói x·ª≠ l√Ω ·∫£nh: ' + error.message);
                  } else {
                    console.error('TinyMCE failure callback not available:', error.message);
                    showStatus('‚ùå L·ªói upload ·∫£nh: ' + error.message, 'error');
                  }
                };
                reader.readAsDataURL(blobInfo.blob());
              } catch (fallbackError) {
                console.error('Fallback error:', fallbackError);
                if (typeof failure === 'function') {
                  failure('L·ªói x·ª≠ l√Ω ·∫£nh: ' + fallbackError.message);
                } else {
                  console.error('TinyMCE failure callback not available:', fallbackError.message);
                  showStatus('‚ùå L·ªói x·ª≠ l√Ω ·∫£nh: ' + fallbackError.message, 'error');
                }
              }
            }
          },
          // Allow paste of images
          paste_data_images: true,

          // Upload settings
          automatic_uploads: true,
          images_upload_url: '', // We handle this in images_upload_handler
          images_reuse_filename: false,

          // Image options
          image_advtab: true,
          image_caption: true,
          image_title: true,

          // Success callback
          init_instance_callback: function (editor) {
            console.log('‚úÖ TinyMCE editor initialized successfully');
            updateEditorStatus('‚úÖ Editor ƒë√£ s·∫µn s√†ng!', 'success');
            editor.on('change', function () {
              editor.save();
            });
          },

          // Error handling
          setup: function (editor) {
            editor.on('LoadContent', function () {
              console.log('‚úÖ TinyMCE content loaded');
            });

            editor.on('Error', function (e) {
              console.error('‚ùå TinyMCE Error:', e);
              updateEditorStatus('‚ùå L·ªói editor: ' + e.message, 'error');
            });
          }
        });

        // Handle initialization result safely - only call then() if it's a Promise
        if (initResult && typeof initResult.then === 'function') {
          initResult.then(function (editors) {
            console.log('‚úÖ TinyMCE initialization Promise resolved');
            updateEditorStatus('‚úÖ Editor ƒë√£ s·∫µn s√†ng!', 'success');
          }).catch(function (error) {
            console.error('‚ùå TinyMCE initialization Promise rejected:', error);
            updateEditorStatus('‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o editor: ' + error.message, 'error');
          });
        } else {
          // TinyMCE initialized synchronously
          console.log('‚úÖ TinyMCE initialized synchronously');
          setTimeout(() => {
            updateEditorStatus('‚úÖ Editor ƒë√£ s·∫µn s√†ng!', 'success');
          }, 1000);
        }

      } catch (error) {
        console.error('‚ùå TinyMCE initialization error:', error);
        updateEditorStatus('‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o editor: ' + error.message, 'error');
      }
    }

    // Initialize TinyMCE when page loads
    document.addEventListener('DOMContentLoaded', function () {
      // Wait a bit for TinyMCE script to load
      setTimeout(initializeTinyMCE, 500);
    });

    // Auto-generate filename from title
    document.getElementById('title').addEventListener('input', function () {
      const title = this.value;
      const filename = generateFilename(title);
      document.getElementById('filename').value = filename;
    });

    // Set default publish date to today
    document.getElementById('publishDate').value = new Date().toISOString().split('T')[0];

    // TinyMCE Helper Functions
    function getTinyMCEEditor() {
      if (typeof tinymce === 'undefined') {
        console.error('TinyMCE not loaded');
        showStatus('Editor ch∆∞a s·∫µn s√†ng. Vui l√≤ng ƒë·ª£i...', 'error');
        return null;
      }

      const editor = tinymce.get('contentEditor');
      if (!editor) {
        console.error('TinyMCE editor not found');
        showStatus('Editor kh√¥ng t√¨m th·∫•y. Vui l√≤ng reload trang.', 'error');
        return null;
      }

      return editor;
    }

    function getTinyMCEContent() {
      const editor = getTinyMCEEditor();
      if (!editor) {
        console.warn('Editor not available, returning empty content');
        return '';
      }

      try {
        return editor.getContent() || '';
      } catch (error) {
        console.error('Error getting TinyMCE content:', error);
        return '';
      }
    }

    function setTinyMCEContent(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        try {
          editor.setContent(content || '');
          console.log('‚úÖ Content set immediately in TinyMCE');
          return true;
        } catch (error) {
          console.error('Error setting TinyMCE content:', error);
          showStatus('‚ùå L·ªói thi·∫øt l·∫≠p n·ªôi dung editor', 'error');
          return false;
        }
      }

      console.warn('‚ö†Ô∏è TinyMCE editor not ready, starting retry sequence...');

      // Multi-stage retry for TinyMCE content loading
      let retryCount = 0;
      const maxRetries = 5;

      const retryInterval = setInterval(() => {
        retryCount++;
        console.log(`üîÑ TinyMCE content retry ${retryCount}/${maxRetries}...`);

        const retryEditor = getTinyMCEEditor();
        if (retryEditor) {
          retryEditor.setContent(content || '');
          console.log('‚úÖ Content loaded into TinyMCE after retry #' + retryCount);
          clearInterval(retryInterval);
          showStatus('‚úÖ N·ªôi dung ƒë√£ ƒë∆∞·ª£c t·∫£i v√†o editor', 'success');
        } else if (retryCount >= maxRetries) {
          console.warn('‚ùå TinyMCE editor still not ready after all retries');
          clearInterval(retryInterval);
          showStatus('‚ö†Ô∏è Editor ch∆∞a s·∫µn s√†ng - vui l√≤ng paste n·ªôi dung th·ªß c√¥ng', 'warning');
        }
      }, 800);

      return false;
    }

    function insertContentToTinyMCE(content) {
      const editor = getTinyMCEEditor();
      if (editor) {
        try {
          editor.insertContent(content);
          return true;
        } catch (error) {
          console.error('Error inserting content to TinyMCE:', error);
          showStatus('‚ùå L·ªói ch√®n n·ªôi dung v√†o editor', 'error');
          return false;
        }
      }
      console.warn('Editor not available for content insertion');
      return false;
    }

    // Image upload handling
    const imageUpload = document.getElementById('imageUpload');
    const imageInput = document.getElementById('imageInput');
    const uploadedImagesContainer = document.getElementById('uploadedImages');

    imageUpload.addEventListener('click', () => imageInput.click());
    imageUpload.addEventListener('dragover', handleDragOver);
    imageUpload.addEventListener('dragleave', handleDragLeave);
    imageUpload.addEventListener('drop', handleDrop);
    imageInput.addEventListener('change', handleFileSelect);

    // Feature Image upload handling
    const featureImageDropzone = document.getElementById('featureImageDropzone');
    const featureImageInput = document.getElementById('featureImageInput');
    const featureImagePreview = document.getElementById('featureImagePreview');
    const featureImageImg = document.getElementById('featureImageImg');

    featureImageDropzone.addEventListener('click', () => featureImageInput.click());
    featureImageDropzone.addEventListener('dragover', handleFeatureImageDragOver);
    featureImageDropzone.addEventListener('dragleave', handleFeatureImageDragLeave);
    featureImageDropzone.addEventListener('drop', handleFeatureImageDrop);
    featureImageInput.addEventListener('change', handleFeatureImageSelect);

    function handleDragOver(e) {
      e.preventDefault();
      imageUpload.classList.add('dragover');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      imageUpload.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      processImages(files);
    }

    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      processImages(files);
    }

    function processImages(files) {
      files.forEach(file => {
        if (file.type.startsWith('image/') && file.size <= 5 * 1024 * 1024) {
          uploadImageToBase64(file);
        } else {
          if (!file.type.startsWith('image/')) {
            showStatus('L·ªói: ' + file.name + ' kh√¥ng ph·∫£i l√† file h√¨nh ·∫£nh', 'error');
          } else {
            showStatus('L·ªói: ' + file.name + ' qu√° l·ªõn (>5MB)', 'error');
          }
        }
      });
    }

    function uploadImageToBase64(file) {
      try {
        showStatus('üì± ƒêang chuy·ªÉn ƒë·ªïi ·∫£nh sang base64: ' + file.name + '...', 'info');

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imageData = {
              id: Date.now() + Math.random(),
              name: file.name,
              data: e.target.result, // Base64 data
              file: file,
              base64: true // Flag to indicate this is base64 data
            };
            uploadedImages.push(imageData);
            renderUploadedImages();
            showStatus('‚úÖ ƒê√£ chuy·ªÉn ƒë·ªïi ·∫£nh sang base64: ' + file.name, 'success');
          } catch (error) {
            console.error('Error processing image:', error);
            showStatus('‚ùå L·ªói khi x·ª≠ l√Ω ·∫£nh: ' + file.name, 'error');
          }
        };

        reader.onerror = function (error) {
          console.error('FileReader error:', error);
          showStatus('‚ùå L·ªói ƒë·ªçc file: ' + file.name, 'error');
        };

        reader.readAsDataURL(file);
      } catch (error) {
        console.error('Image conversion error:', error);
        showStatus('‚ùå L·ªói chuy·ªÉn ƒë·ªïi ·∫£nh: ' + error.message, 'error');
      }
    }

    // Feature Image handling functions
    function handleFeatureImageDragOver(e) {
      e.preventDefault();
      featureImageDropzone.classList.add('dragover');
    }

    function handleFeatureImageDragLeave(e) {
      e.preventDefault();
      featureImageDropzone.classList.remove('dragover');
    }

    function handleFeatureImageDrop(e) {
      e.preventDefault();
      featureImageDropzone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      if (files.length > 0) {
        processFeatureImage(files[0]); // Only take the first file
      }
    }

    function handleFeatureImageSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        processFeatureImage(files[0]);
      }
    }

    function processFeatureImage(file) {
      if (!file.type.startsWith('image/')) {
        showStatus('L·ªói: ' + file.name + ' kh√¥ng ph·∫£i l√† file h√¨nh ·∫£nh', 'error');
        return;
      }

      if (file.size > 5 * 1024 * 1024) {
        showStatus('L·ªói: ' + file.name + ' qu√° l·ªõn (>5MB)', 'error');
        return;
      }

      uploadFeatureImageToBase64(file);
    }

    function uploadFeatureImageToBase64(file) {
      try {
        showStatus('üåü ƒêang chuy·ªÉn ƒë·ªïi ·∫£nh ƒë·∫°i di·ªán sang base64: ' + file.name + '...', 'info');

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const base64Data = e.target.result;

            // Store feature image data as base64
            featureImage = {
              id: Date.now() + Math.random(),
              name: file.name,
              url: base64Data, // Store base64 data directly
              file: file,
              base64: true // Flag to indicate this is base64 data
            };

            // Show preview
            showFeatureImagePreview(base64Data);
            showStatus('‚úÖ ƒê√£ chuy·ªÉn ƒë·ªïi ·∫£nh ƒë·∫°i di·ªán sang base64: ' + file.name, 'success');

          } catch (previewError) {
            console.error('Feature image preview error:', previewError);
            showStatus('‚ùå L·ªói hi·ªÉn th·ªã preview: ' + previewError.message, 'error');
          }
        };

        reader.onerror = function (error) {
          console.error('Feature image FileReader error:', error);
          showStatus('‚ùå L·ªói ƒë·ªçc file ·∫£nh: ' + file.name, 'error');
        };

        // Convert to base64
        reader.readAsDataURL(file);

      } catch (error) {
        console.error('Feature image base64 conversion error:', error);
        showStatus('‚ùå L·ªói chuy·ªÉn ƒë·ªïi ·∫£nh: ' + file.name + ': ' + error.message, 'error');
      }
    }

    function showFeatureImagePreview(imageUrl) {
      featureImageImg.src = imageUrl;
      featureImagePreview.style.display = 'block';
      featureImageDropzone.style.display = 'none';
    }

    function removeFeatureImage() {
      showQuestionModal(
        'üóëÔ∏è X√≥a ·∫£nh ƒë·∫°i di·ªán?',
        'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ·∫£nh ƒë·∫°i di·ªán hi·ªán t·∫°i?',
        () => {
          // Yes action - remove feature image
          featureImage = null;
          featureImagePreview.style.display = 'none';
          featureImageDropzone.style.display = 'block';
          featureImageInput.value = '';
          showSuccessModal('üóëÔ∏è ƒê√£ x√≥a ·∫£nh ƒë·∫°i di·ªán', '·∫¢nh ƒë·∫°i di·ªán ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!');
        },
        () => {
          // No action - do nothing
          console.log('User cancelled feature image removal');
        }
      );
    }

    function changeFeatureImage() {
      featureImageInput.click();
    }

    function renderUploadedImages() {
      uploadedImagesContainer.innerHTML = uploadedImages.map(img =>
        '<div class="uploaded-image">' +
        '<img src="' + img.data + '" alt="' + img.name + '">' +
        '<div class="image-actions">' +
        '<span class="image-type">üì± Base64</span>' +
        '<button type="button" class="image-btn" onclick="insertImageToEditor(' + "'" + img.name + "'" + ', ' + "'" + img.data + "'" + ')" title="Ch√®n v√†o editor">üìù</button>' +
        '<button type="button" class="image-btn" onclick="copyImagePath(' + "'" + img.name + "'" + ')" title="Copy ƒë∆∞·ªùng d·∫´n">üìã</button>' +
        '<button type="button" class="image-btn" onclick="removeImage(' + "'" + img.id + "'" + ')" title="X√≥a ·∫£nh">üóëÔ∏è</button>' +
        '</div>' +
        '</div>'
      ).join('');
    }

    function insertImageToEditor(imageName, imageData) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;
      const altText = imageName.replace(/\.[^/.]+$/, ""); // Remove file extension for alt text

      // Insert image into TinyMCE editor
      if (!insertContentToTinyMCE(
        '<p><img src="' + path + '" alt="' + altText + '" style="width: 100%; max-width: 600px; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></p>'
      )) {
        showStatus('Kh√¥ng th·ªÉ ch√®n ·∫£nh. Editor ch∆∞a s·∫µn s√†ng.', 'error');
        return;
      }

      showStatus('ƒê√£ ch√®n ·∫£nh v√†o editor!', 'success');
    }

    function copyImagePath(imageName) {
      const path = '/assets/tin-tuc/' + generateFilename(document.getElementById('title').value).replace('.html', '') + '/' + imageName;

      // Check if clipboard API is available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(path).then(() => {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + path, 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(path);
        });
      } else {
        fallbackCopyToClipboard(path);
      }
    }

    function fallbackCopyToClipboard(text) {
      // Fallback method for copying text
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showStatus('ƒê√£ copy ƒë∆∞·ªùng d·∫´n ·∫£nh: ' + text, 'success');
        } else {
          showStatus('Kh√¥ng th·ªÉ copy. ƒê∆∞·ªùng d·∫´n: ' + text, 'error');
        }
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showStatus('ƒê∆∞·ªùng d·∫´n ·∫£nh: ' + text + ' (copy th·ªß c√¥ng)', 'error');
      }

      document.body.removeChild(textArea);
    }

    function removeImage(imageId) {
      const imageToRemove = uploadedImages.find(img => img.id === imageId);
      if (!imageToRemove) return;

      try {
        // Remove from local array (base64 images are stored locally only)
        uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        renderUploadedImages();
        showStatus('‚úÖ ƒê√£ x√≥a ·∫£nh: ' + imageToRemove.name, 'success');

      } catch (error) {
        console.error('Error removing image:', error);
        showStatus('‚ùå L·ªói x√≥a ·∫£nh: ' + error.message, 'error');
      }
    }

    // Function to link orphaned TinyMCE images with the article
    async function linkEditorImages(articleId, htmlContent) {
      try {
        const client = await initializeSupabase();
        if (!client) return;

        // Get all unlinked TinyMCE images (article_id is null)
        const { data: orphanedImages, error } = await client
          .from('article_images')
          .select('*')
          .is('article_id', null);

        if (error) {
          if (error.message && error.message.includes('row-level security')) {
            console.warn('üîí RLS policy blocks reading article_images - skipping image linking');
            return;
          }
          console.warn('‚ö†Ô∏è Error reading orphaned images:', error);
          return;
        }

        if (!orphanedImages || orphanedImages.length === 0) return;

        // Find images that are used in this article's content
        const usedImages = orphanedImages.filter(img => {
          // Get public URL for comparison
          const { data: { publicUrl } } = client.storage
            .from('images')
            .getPublicUrl(img.storage_path);
          return htmlContent.includes(publicUrl);
        });

        // Link these images to the article
        for (const img of usedImages) {
          try {
            await client
              .from('article_images')
              .update({ article_id: articleId })
              .eq('id', img.id);
          } catch (updateError) {
            if (updateError.message && updateError.message.includes('row-level security')) {
              console.warn(`üîí RLS policy blocks updating image ${img.filename} - skipping`);
            } else {
              console.warn(`‚ö†Ô∏è Error linking image ${img.filename}:`, updateError);
            }
          }
        }

        if (usedImages.length > 0) {
          console.log(`‚úÖ Linked ${usedImages.length} TinyMCE images to article ${articleId}`);
          showStatus(`‚úÖ ƒê√£ li√™n k·∫øt ${usedImages.length} ·∫£nh TinyMCE v·ªõi b√†i vi·∫øt`, 'success');
        }

      } catch (error) {
        console.error('Error linking editor images:', error);
      }
    }

    // Function to cleanup orphaned images (images not linked to any article after 24 hours)
    async function cleanupOrphanedImages() {
      try {
        const client = await initializeSupabase();
        if (!client) return;

        // Get images that are orphaned for more than 24 hours
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();

        const { data: orphanedImages, error } = await client
          .from('article_images')
          .select('*')
          .is('article_id', null)
          .lt('created_at', twentyFourHoursAgo);

        if (error) {
          if (error.message && error.message.includes('row-level security')) {
            console.warn('üîí RLS policy blocks reading article_images - skipping orphaned cleanup');
            return;
          }
          console.warn('‚ö†Ô∏è Error reading orphaned images:', error);
          return;
        }

        if (!orphanedImages || orphanedImages.length === 0) return;

        console.log(`üßπ Found ${orphanedImages.length} orphaned images to cleanup`);

        // Delete orphaned images
        for (const img of orphanedImages) {
          try {
            // Delete from storage
            await client.storage
              .from('images')
              .remove([img.storage_path]);

            // Delete from database
            try {
              await client
                .from('article_images')
                .delete()
                .eq('id', img.id);
            } catch (deleteError) {
              if (deleteError.message && deleteError.message.includes('row-level security')) {
                console.warn(`üîí RLS policy blocks deleting image ${img.filename} from DB - storage file removed`);
              } else {
                console.warn(`‚ö†Ô∏è Failed to delete image ${img.filename} from DB:`, deleteError);
              }
            }

            console.log(`üóëÔ∏è Deleted orphaned image: ${img.filename}`);
          } catch (delError) {
            if (delError.message && delError.message.includes('row-level security')) {
              console.warn(`üîí RLS policy blocks deleting orphaned image ${img.filename}`);
            } else {
              console.warn(`‚ö†Ô∏è Failed to delete orphaned image ${img.filename}:`, delError);
            }
          }
        }

        if (orphanedImages.length > 0) {
          showStatus(`üßπ ƒê√£ d·ªçn d·∫πp ${orphanedImages.length} ·∫£nh r√°c`, 'info');
        }

      } catch (error) {
        console.error('Error cleaning up orphaned images:', error);
      }
    }

    // Function to cleanup unused editor images
    async function cleanupEditorImages(articleId, htmlContent) {
      try {
        const client = await initializeSupabase();
        if (!client) return;

        // Get all images associated with this article from TinyMCE
        const { data: editorImages, error } = await client
          .from('article_images')
          .select('*')
          .eq('article_id', articleId);

        if (error) {
          if (error.message && error.message.includes('row-level security')) {
            console.warn('üîí RLS policy blocks reading article_images - skipping cleanup');
            return;
          }
          console.warn('‚ö†Ô∏è Error reading editor images:', error);
          return;
        }

        if (!editorImages || editorImages.length === 0) return;

        // Check which images are still used in the HTML content
        const unusedImages = editorImages.filter(img => {
          // Get public URL for comparison
          const { data: { publicUrl } } = client.storage
            .from('images')
            .getPublicUrl(img.storage_path);
          return !htmlContent.includes(publicUrl);
        });

        // Delete unused images
        for (const img of unusedImages) {
          try {
            // Delete from storage
            await client.storage
              .from('images')
              .remove([img.storage_path]);

            // Delete from database
            try {
              await client
                .from('article_images')
                .delete()
                .eq('id', img.id);
            } catch (deleteError) {
              if (deleteError.message && deleteError.message.includes('row-level security')) {
                console.warn(`üîí RLS policy blocks deleting image ${img.filename} from DB - storage file removed`);
              } else {
                console.warn(`‚ö†Ô∏è Failed to delete image ${img.filename} from DB:`, deleteError);
              }
            }

            console.log('üóëÔ∏è Cleaned up unused editor image:', img.filename);
          } catch (cleanupError) {
            if (cleanupError.message && cleanupError.message.includes('row-level security')) {
              console.warn(`üîí RLS policy blocks cleanup for image ${img.filename}`);
            } else {
              console.warn('Could not cleanup image:', img.filename, cleanupError);
            }
          }
        }

        if (unusedImages.length > 0) {
          showStatus(`üßπ ƒê√£ d·ªçn d·∫πp ${unusedImages.length} ·∫£nh kh√¥ng s·ª≠ d·ª•ng`, 'success');
        }

      } catch (error) {
        console.warn('Editor image cleanup failed:', error);
      }
    }

    function generateFilename(title) {
      if (!title) return '';
      return title
        .toLowerCase()
        .replace(/[√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠]/g, 'a')
        .replace(/[√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá]/g, 'e')
        .replace(/[√≠√¨·ªâƒ©·ªã]/g, 'i')
        .replace(/[√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£]/g, 'o')
        .replace(/[√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±]/g, 'u')
        .replace(/[√Ω·ª≥·ª∑·ªπ·ªµ]/g, 'y')
        .replace(/ƒë/g, 'd')
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') + '.html';
    }

    // Template Engine Functions
    let templateEngine = null;

    async function initializeTemplateEngine() {
      if (!templateEngine) {
        templateEngine = new NewsTemplateEngine();
        console.log('‚úÖ Template Engine initialized');
      }
      return templateEngine;
    }

    function prepareTemplateData(formData) {
      const now = new Date();
      const publishDate = formData.publishDate || now.toISOString().split('T')[0];

      return {
        // Basic article data
        title: formData.title,
        content: formData.content,
        category: formData.category || 'Tin t·ª©c',
        filename: formData.filename,
        publishDate: publishDate,
        modifiedDate: now.toISOString().split('T')[0],

        // Meta data for SEO
        meta: {
          description: formData.description || '',
          keywords: formData.keywords || '',
          author: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          robots: 'index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1',
          featured: formData.featured || false,
          image: (formData.featureImage && formData.featureImage.url) ? formData.featureImage.url : 'https://baohiembaovietdanang.vn/assets/logo.png',
          imageAlt: formData.imageAlt || formData.title
        },

        // Site configuration
        site: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          domain: 'https://baohiembaovietdanang.vn'
        },

        // Tags and related content
        tags: formData.tags ? formData.tags.split(',').map(tag => tag.trim()) : [],

        // Related articles (you can customize this)
        relatedArticles: [
          {
            title: 'B·∫£o hi·ªÉm s·ª©c kh·ªèe B·∫£o Vi·ªát c√≥ n√™n mua? B·∫£ng gi√° 2025',
            summary: 'Chi ti·∫øt v·ªÅ s·∫£n ph·∫©m b·∫£o hi·ªÉm s·ª©c kh·ªèe m·ªõi nh·∫•t t·ª´ B·∫£o Vi·ªát...',
            url: 'bao-hiem-suc-khoe-bao-viet-co-nen-mua-bang-gia-2025.html'
          },
          {
            title: 'B·∫£o hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng - Gi·∫£i ph√°p to√†n di·ªán',
            summary: 'T√¨m hi·ªÉu v·ªÅ c√°c g√≥i b·∫£o hi·ªÉm t·ªëi ∆∞u cho gia ƒë√¨nh...',
            url: 'bao-hiem-bao-viet-danang-giai-phap-toan-dien.html'
          }
        ],

        // Analytics (optional)
        analytics: {
          gtag: 'GA_MEASUREMENT_ID' // Replace with actual GA ID if needed
        },

        // Author info (optional)
        author: {
          name: 'B·∫£o Hi·ªÉm B·∫£o Vi·ªát ƒê√† N·∫µng',
          bio: 'Chuy√™n gia t∆∞ v·∫•n b·∫£o hi·ªÉm h√†ng ƒë·∫ßu t·∫°i ƒê√† N·∫µng'
        }
      };
    }

    async function previewTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang t·∫°o preview...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Open in new window
        const previewWindow = window.open('', '_blank');
        previewWindow.document.open();
        previewWindow.document.write(html);
        previewWindow.document.close();

        showStatus('‚úÖ Preview ƒë√£ m·ªü trong tab m·ªõi!', 'success');

      } catch (error) {
        console.error('Preview error:', error);
        showStatus('‚ùå L·ªói t·∫°o preview: ' + error.message, 'error');
      }
    }

    async function exportTemplateHTML() {
      try {
        const formData = getFormData();
        if (!formData.title || !formData.content) {
          showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
          return;
        }

        showStatus('üîÑ ƒêang xu·∫•t HTML...', 'info');

        const engine = await initializeTemplateEngine();
        const templateData = prepareTemplateData(formData);

        const html = await engine.processTemplate('./templates/news/article.html', templateData);

        // Create download
        const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('üíæ ƒê√£ xu·∫•t file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(templateData);

      } catch (error) {
        console.error('Export error:', error);
        showStatus('‚ùå L·ªói xu·∫•t HTML: ' + error.message, 'error');
      }
    }

    function previewArticle() {
      const formData = getFormData();
      if (!formData.title || !formData.content) {
        showStatus('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ v√† n·ªôi dung', 'error');
        return;
      }

      showStatus('Ch·ª©c nƒÉng xem tr∆∞·ªõc ƒë√£ b·ªã x√≥a', 'info');
    }

    function closePreview() {
      document.getElementById('previewContainer').style.display = 'none';
    }

    function getFormData() {
      return {
        title: document.getElementById('title').value,
        description: document.getElementById('description').value,
        category: document.getElementById('category').value,
        publishDate: document.getElementById('publishDate').value,
        keywords: document.getElementById('keywords').value,
        tags: document.getElementById('tags').value,
        featured: document.getElementById('featured').checked,
        filename: document.getElementById('filename').value,
        content: getTinyMCEContent(),
        featureImage: featureImage // Include feature image data
        // Note: status will be set automatically by save functions
      };
    }

    function clearForm() {
      showQuestionModal(
        'üóëÔ∏è X√≥a to√†n b·ªô form?',
        'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô n·ªôi dung form hi·ªán t·∫°i? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.',
        () => {
          // Yes action - clear form
          document.getElementById('newsForm').reset();
          setTinyMCEContent('');
          uploadedImages = [];
          renderUploadedImages();

          // Reset feature image
          featureImage = null;
          featureImagePreview.style.display = 'none';
          featureImageDropzone.style.display = 'block';
          featureImageInput.value = '';

          closePreview();

          showSuccessModal('üóëÔ∏è ƒê√£ x√≥a form', 'To√†n b·ªô n·ªôi dung form ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!');
        },
        () => {
          // No action - do nothing
          console.log('User cancelled form clearing');
        }
      );
    }

    // Draft/Publish Status Functions
    async function saveDraft() {
      const loadingModal = showLoadingModal('üíæ ƒêang l∆∞u nh√°p...', 'Vui l√≤ng ƒë·ª£i trong khi h·ªá th·ªëng l∆∞u b√†i vi·∫øt d·∫°ng nh√°p.');

      try {
        await saveToSupabaseWithStatus('draft', false); // draft, no deploy
        hideNotificationModal();
        showSuccessModal('‚úÖ L∆∞u nh√°p th√†nh c√¥ng!', 'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c l∆∞u d·∫°ng nh√°p v√† c√≥ th·ªÉ ch·ªânh s·ª≠a sau.');
      } catch (error) {
        console.error('Save draft error:', error);
        hideNotificationModal();
        showErrorNotification('‚ùå L·ªói l∆∞u nh√°p', 'C√≥ l·ªói x·∫£y ra khi l∆∞u nh√°p: ' + error.message);
      }
    }

    async function saveAndPublish() {
      const loadingModal = showLoadingModal('üìù ƒêang l∆∞u v√† xu·∫•t b·∫£n...', 'H·ªá th·ªëng ƒëang l∆∞u b√†i vi·∫øt v√† chu·∫©n b·ªã xu·∫•t b·∫£n.');

      try {
        await saveToSupabaseWithStatus('published', true); // published, auto-deploy
        await updateNewsPage()
        hideNotificationModal();
        showSuccessModal('‚úÖ Xu·∫•t b·∫£n th√†nh c√¥ng!', 'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c l∆∞u v√† xu·∫•t b·∫£n th√†nh c√¥ng!');
      } catch (error) {
        console.error('Save and publish error:', error);
        hideNotificationModal();
        showErrorNotification('‚ùå L·ªói xu·∫•t b·∫£n', 'C√≥ l·ªói x·∫£y ra khi l∆∞u v√† xu·∫•t b·∫£n: ' + error.message);
      }
    }

    async function saveAndDeploy() {
      const loadingModal = showLoadingModal('üöÄ ƒêang deploy...', 'H·ªá th·ªëng ƒëang l∆∞u, xu·∫•t b·∫£n v√† deploy t·ª± ƒë·ªông l√™n GitHub Pages.');

      try {
        await saveToSupabaseWithStatus('published', true); // published, with auto-deploy
        hideNotificationModal();
        showSuccessModal('‚úÖ Deploy th√†nh c√¥ng!', 'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c l∆∞u, xu·∫•t b·∫£n v√† deploy th√†nh c√¥ng!');
      } catch (error) {
        console.error('Save and deploy error:', error);
        hideNotificationModal();
        showErrorNotification('‚ùå L·ªói deploy', 'C√≥ l·ªói x·∫£y ra khi deploy: ' + error.message);
      }
    }

    // Supabase Functions
    async function saveToSupabaseWithStatus(status = 'draft', shouldDeploy = false) {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase. Vui l√≤ng c·∫•u h√¨nh URL v√† API key.', 'error');
        return;
      }

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        // Generate rendered HTML template
        let renderedHTML = null;
        try {
          const engine = await initializeTemplateEngine();
          const templateData = prepareTemplateData(formData);
          renderedHTML = await engine.processTemplate('./templates/news/article.html', templateData);
          console.log('‚úÖ Template rendered successfully for Supabase');
        } catch (templateError) {
          console.warn('‚ö†Ô∏è Could not render template for Supabase:', templateError);
          showStatus('‚ö†Ô∏è L∆∞u kh√¥ng c√≥ template HTML - ch·ªâ l∆∞u d·ªØ li·ªáu th√¥', 'warning');
        }

        // Prepare article data for Supabase with status
        const articleData = {
          title: formData.title,
          description: formData.description,
          content: formData.content,
          category: formData.category,
          keywords: formData.keywords,
          filename: formData.filename,
          published_date: formData.publishDate || new Date().toISOString().split('T')[0],
          is_published: status === 'published',
          status: status // Add status field
        };

        // Add optional fields if they exist in form
        if (formData.tags) {
          articleData.tags = formData.tags;
        }

        if (formData.featured !== undefined) {
          articleData.is_featured = formData.featured;
        }

        if (formData.featureImage && formData.featureImage.url) {
          articleData.feature_image_url = formData.featureImage.url;
        }

        if (renderedHTML) {
          articleData.rendered_html = renderedHTML;
          articleData.template_version = '1.0';
        }

        let savedArticle;

        // Check if we're editing an existing article
        if (window.currentEditingId) {
          // Update existing article
          const { data, error } = await client
            .from('articles')
            .update(articleData)
            .eq('id', window.currentEditingId)
            .select()
            .single();

          if (error) throw error;
          savedArticle = data;
          showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t b√†i vi·∫øt th√†nh c√¥ng!', 'success');
        } else {
          // Insert new article
          const { data, error } = await client
            .from('articles')
            .upsert(articleData, {
              onConflict: 'filename',
              ignoreDuplicates: false
            })
            .select()
            .single();

          if (error) throw error;
          savedArticle = data;
          showStatus('‚úÖ ƒê√£ t·∫°o b√†i vi·∫øt m·ªõi th√†nh c√¥ng!', 'success');
        }

        // Associate uploaded Supabase images with this article
        const supabaseImages = uploadedImages.filter(img => !img.local && img.supabase_id);
        if (supabaseImages.length > 0) {
          for (const img of supabaseImages) {
            await client
              .from('article_images')
              .update({ article_id: savedArticle.id })
              .eq('id', img.supabase_id);
          }
          showStatus('‚úÖ ƒê√£ li√™n k·∫øt ' + supabaseImages.length + ' ·∫£nh v·ªõi b√†i vi·∫øt', 'success');
        }

        console.log('Article saved with status:', status, savedArticle);

        // Link TinyMCE images with this article
        try {
          await linkEditorImages(savedArticle.id, formData.content);
        } catch (linkError) {
          console.warn('TinyMCE image linking failed:', linkError);
        }

        // Cleanup unused editor images
        try {
          await cleanupEditorImages(savedArticle.id, formData.content);
        } catch (cleanupError) {
          console.warn('Editor image cleanup failed:', cleanupError);
        }

        // Deploy logic - only deploy if requested and status is published
        if (shouldDeploy && status === 'published') {
          try {
            showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông xu·∫•t b·∫£n GitHub Pages...', 'info');
            await triggerGitHubDeploy(savedArticle);
            showStatus('‚úÖ Xu·∫•t b·∫£n th√†nh c√¥ng!', 'success');
          } catch (deployError) {
            console.warn('‚ö†Ô∏è Auto-deploy failed:', deployError);
            showStatus('‚ö†Ô∏è L∆∞u th√†nh c√¥ng nh∆∞ng t·ª± ƒë·ªông xu·∫•t b·∫£n th·∫•t b·∫°i. C√≥ th·ªÉ xu·∫•t b·∫£n th·ªß c√¥ng sau.', 'warning');
          }
        }

        // Optional: Also create HTML file for published articles
        if (renderedHTML && status === 'published') {
          // Use modal instead of confirm()
          showQuestionModal(
            'üíæ T·∫£i file HTML?',
            'B·∫°n c√≥ mu·ªën t·∫£i file HTML ho√†n ch·ªânh c·ªßa b√†i vi·∫øt kh√¥ng?',
            () => {
              // Yes action - download HTML file
              const blob = new Blob([renderedHTML], { type: 'text/html;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = formData.filename;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);

              showSuccessModal('üíæ ƒê√£ t·∫£i file HTML', 'File HTML ho√†n ch·ªânh ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng th√†nh c√¥ng!');
            },
            () => {
              // No action - do nothing
              console.log('User chose not to download HTML file');
            }
          );
        }

      } catch (error) {
        console.error('Supabase save error:', error);
        showStatus('‚ùå L·ªói l∆∞u v√†o database: ' + error.message, 'error');
        throw error; // Re-throw to be caught by calling function
      }
    }

    // Legacy function for backward compatibility
    async function saveToSupabase() {
      // Default to published status for legacy behavior
      await saveToSupabaseWithStatus('published', true);
    }

    async function loadArticlesList() {
      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showErrorNotification('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'Vui l√≤ng c·∫•u h√¨nh Supabase tr∆∞·ªõc khi t·∫£i danh s√°ch b√†i vi·∫øt.');
        return;
      }

      const loadingModal = showLoadingModal('‚è≥ ƒêang t·∫£i danh s√°ch...', 'H·ªá th·ªëng ƒëang t·∫£i danh s√°ch b√†i vi·∫øt t·ª´ database.');

      try {
        const { data, error } = await client
          .from('articles')
          .select('id, title, filename, category, published_date, is_published, created_at')
          .order('created_at', { ascending: false });

        if (error) {
          throw error;
        }

        hideNotificationModal();

        showArticlesList(data);

      } catch (error) {
        console.error('Load articles error:', error);
        hideNotificationModal();
        showErrorNotification('‚ùå L·ªói t·∫£i danh s√°ch', 'C√≥ l·ªói x·∫£y ra khi t·∫£i danh s√°ch b√†i vi·∫øt: ' + error.message);
      }
    }

    function showArticlesList(articles) {
      if (articles.length === 0) {
        showWarningModal('üì≠ Ch∆∞a c√≥ b√†i vi·∫øt', 'Database ch∆∞a c√≥ b√†i vi·∫øt n√†o. H√£y t·∫°o b√†i vi·∫øt ƒë·∫ßu ti√™n!');
        return;
      }

      let listHTML = '<h3>üìã Danh s√°ch b√†i vi·∫øt</h3><ul style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 1rem; margin: 1rem 0;">';

      articles.forEach(article => {
        const publishedBadge = article.is_published ? '‚úÖ' : '‚è≥';
        const dateStr = new Date(article.created_at).toLocaleDateString('vi-VN');

        listHTML +=
          '<li style="margin-bottom: 0.5rem; padding: 0.5rem; border-bottom: 1px solid #eee;">' +
          '<strong>' + publishedBadge + ' ' + article.title + '</strong><br>' +
          '<small>üìÇ ' + article.category + ' | üìÖ ' + dateStr + ' | üìÑ ' + article.filename + '</small><br>' +
          '<div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">' +
          '<button onclick="loadArticle(' + "'" + article.id + "'" + ')" class="btn btn-primary"' +
          ' style="font-size: 0.8rem; padding: 0.25rem 0.5rem;">' +
          'üìù Ch·ªânh s·ª≠a' +
          '</button>' +
          '<button onclick="deleteArticle(' + "'" + article.id + "'" + ', ' + JSON.stringify(article.title) + ')" class="btn btn-danger"' +
          ' style="font-size: 0.8rem; padding: 0.25rem 0.5rem; background: #dc3545; color: white; border: 1px solid #dc3545;"' +
          ' onmouseover="this.style.background=\'#c82333\'" onmouseout="this.style.background=\'#dc3545\'">' +
          'üóëÔ∏è X√≥a' +
          '</button>' +
          '</div>' +
          '</li>';
      });

      listHTML += '</ul>';

      // Show in preview container
      document.getElementById('previewContent').innerHTML = listHTML;
      document.getElementById('previewContainer').style.display = 'block';
    }

    async function loadArticle(articleId) {
      // Update URL v·ªõi edit parameter ƒë·ªÉ workflow edit ho·∫°t ƒë·ªông ƒë√∫ng
      const currentUrl = new URL(window.location);
      currentUrl.searchParams.set('edit', articleId);
      window.history.pushState({ edit: articleId }, '', currentUrl.toString());

      // G·ªçi lu√¥n function loadArticleForEdit ƒë√£ t·ªëi ∆∞u thay v√¨ duplicate code
      try {
        await loadArticleForEdit(articleId);

        // Hide preview container sau khi load th√†nh c√¥ng
        closePreview();

        showStatus('‚úÖ ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô ch·ªânh s·ª≠a b√†i vi·∫øt ID: ' + articleId, 'success');

      } catch (error) {
        console.error('Load article error:', error);
        showStatus('‚ùå L·ªói t·∫£i b√†i vi·∫øt: ' + error.message, 'error');
      }
    }

    async function deleteArticle(articleId, articleTitle) {
      const confirmed = await showQuestionModal(
        'üóëÔ∏è X√°c nh·∫≠n x√≥a b√†i vi·∫øt',
        `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a b√†i vi·∫øt "${articleTitle}"?\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!`,
        'X√≥a b√†i vi·∫øt',
        'H·ªßy b·ªè'
      );

      if (!confirmed) {
        return;
      }

      // Initialize Supabase if not already done
      const client = await initializeSupabase();

      if (!client) {
        showErrorNotification('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'Vui l√≤ng c·∫•u h√¨nh Supabase tr∆∞·ªõc khi x√≥a b√†i vi·∫øt.');
        return;
      }

      const loadingModal = showLoadingModal('üóëÔ∏è ƒêang x√≥a b√†i vi·∫øt...', 'H·ªá th·ªëng ƒëang x√≥a b√†i vi·∫øt t·ª´ database.');

      try {
        // First get article details to know the filename
        const { data: articleData, error: fetchError } = await client
          .from('articles')
          .select('filename')
          .eq('id', articleId)
          .single();

        if (fetchError) {
          throw fetchError;
        }

        // Delete the article from database
        const { error: deleteError } = await client
          .from('articles')
          .delete()
          .eq('id', articleId);

        if (deleteError) {
          throw deleteError;
        }

        hideNotificationModal();

        // Show success and ask about updating news page
        const shouldUpdateNews = await showQuestionModal(
          '‚úÖ ƒê√£ x√≥a b√†i vi·∫øt th√†nh c√¥ng',
          'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi database.\n\nB·∫°n c√≥ mu·ªën c·∫≠p nh·∫≠t trang tin t·ª©c ngay b√¢y gi·ªù?',
          'C·∫≠p nh·∫≠t tin t·ª©c',
          'ƒê·ªÉ sau'
        );

        if (shouldUpdateNews) {
          await triggerNewsUpdate(articleData.filename);
        }

        // Refresh the articles list
        await loadArticlesList();

        showSuccessNotification('‚úÖ X√≥a th√†nh c√¥ng', `B√†i vi·∫øt "${articleTitle}" ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi h·ªá th·ªëng.`);

      } catch (error) {
        console.error('Delete article error:', error);
        hideNotificationModal();
        showErrorNotification('‚ùå L·ªói x√≥a b√†i vi·∫øt', 'C√≥ l·ªói x·∫£y ra khi x√≥a b√†i vi·∫øt: ' + error.message);
      }
    }

    async function triggerNewsUpdate(deletedFilename) {
      const loadingModal = showLoadingModal('üì∞ ƒêang c·∫≠p nh·∫≠t trang tin t·ª©c...', 'H·ªá th·ªëng ƒëang c·∫≠p nh·∫≠t trang tin t·ª©c v√† x√≥a file HTML.');

      try {
        // For now, show a manual instruction since we don't have GitHub token in browser
        hideNotificationModal();

        const manualSteps = `
        <div style="text-align: left; line-height: 1.6;">
          <h4>üìã C√°ch c·∫≠p nh·∫≠t th·ªß c√¥ng:</h4>
          <ol style="margin: 1rem 0; padding-left: 1.5rem;">
            <li>V√†o GitHub repository: <strong>Liam-and-Son-Group/baoviet-danang</strong></li>
            <li>Ch·ªçn tab <strong>Actions</strong></li>
            <li>T√¨m workflow <strong>"Update News Page"</strong></li>
            <li>Click <strong>"Run workflow"</strong></li>
            <li>Ch·ªçn action = <strong>"delete"</strong></li>
            <li>Nh·∫≠p filename = <strong>"${deletedFilename}"</strong></li>
            <li>Click <strong>"Run workflow"</strong></li>
          </ol>
          <p style="margin-top: 1rem; padding: 1rem; background: #e3f2fd; border-radius: 6px; color: #1976d2;">
            üí° <strong>Tip:</strong> Workflow s·∫Ω t·ª± ƒë·ªông x√≥a file HTML v√† c·∫≠p nh·∫≠t trang tin t·ª©c trong v√†i ph√∫t.
          </p>
        </div>
        `;

        showInfoModal('üì∞ H∆∞·ªõng d·∫´n c·∫≠p nh·∫≠t tin t·ª©c', manualSteps, false);

      } catch (error) {
        console.error('Trigger news update error:', error);
        hideNotificationModal();
        showWarningModal('‚ö†Ô∏è C·∫ßn c·∫≠p nh·∫≠t th·ªß c√¥ng', 'Kh√¥ng th·ªÉ t·ª± ƒë·ªông c·∫≠p nh·∫≠t trang tin t·ª©c. Vui l√≤ng c·∫≠p nh·∫≠t th·ªß c√¥ng ho·∫∑c th√¥ng b√°o v·ªõi qu·∫£n tr·ªã vi√™n.');
      }
    }

    function downloadHTMLFile(formData) {
      showStatus('Ch·ª©c nƒÉng t·∫£i file ƒë√£ b·ªã x√≥a', 'info');
    }

    // Status functions
    function showStatus(message, type) {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status-message status-' + type;
      statusEl.style.display = 'block';

      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 5000);
    }

    function updateEditorStatus(message, type) {
      const statusEl = document.getElementById('editor-status');
      const textEl = document.getElementById('editor-status-text');

      if (statusEl && textEl) {
        textEl.textContent = message;
        statusEl.className = 'editor-status';
        if (type) {
          statusEl.classList.add(type);
        }
      }
    }

    // Form submission
    document.getElementById('newsForm').addEventListener('submit', function (e) {
      e.preventDefault();

      const formData = getFormData();

      if (!formData.title || !formData.description || !formData.content) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc', 'error');
        return;
      }

      try {
        showStatus('Ch·ª©c nƒÉng t·∫°o file HTML ƒë√£ b·ªã x√≥a', 'info');
        return;

        // Create download
        const blob = new Blob([articleHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = formData.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('ƒê√£ t·∫°o th√†nh c√¥ng file: ' + formData.filename, 'success');

        // Generate sitemap entry
        generateSitemapEntry(formData);

      } catch (error) {
        showStatus('C√≥ l·ªói x·∫£y ra khi t·∫°o b√†i vi·∫øt: ' + error.message, 'error');
        console.error(error);
      }
    });

    function generateSitemapEntry(data) {
      const sitemapEntry = '    <url>\n        <loc>https://baohiembaovietdanang.vn/' + data.filename + '</loc>\n        <lastmod>' +
        (data.publishDate || new Date().toISOString().split('T')[0]) + '</lastmod>\n        <changefreq>monthly</changefreq>\n        <priority>0.9</priority>\n    </url>';

      console.log('Sitemap entry to add:', sitemapEntry);

      // Copy to clipboard with error handling
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(sitemapEntry).then(() => {
          showStatus('ƒê√£ copy sitemap entry v√†o clipboard. Th√™m v√†o sitemap.xml!', 'success');
        }).catch(err => {
          console.error('Clipboard error:', err);
          fallbackCopyToClipboard(sitemapEntry);
        });
      } else {
        fallbackCopyToClipboard(sitemapEntry);
      }
    }

    // Initialize application when page loads
    async function initializeApp() {
      try {
        // Check access first
        if (!checkAccess()) {
          console.log('‚ùå Access check failed, redirecting to login');
          return;
        }

        console.log('‚úÖ Access check passed');

        // Initialize Supabase in background (non-blocking)
        initializeSupabase().then(() => {
          console.log('‚úÖ Supabase initialized');
          // Run cleanup orphaned images after Supabase is ready
          cleanupOrphanedImages().catch(error => {
            console.warn('‚ö†Ô∏è Orphaned image cleanup failed:', error);
          });
        }).catch(error => {
          console.log('Supabase initialization failed, using local mode:', error);
        });

        // Initialize Template Engine in background
        initializeTemplateEngine().then(() => {
          console.log('‚úÖ Template Engine ready');
          showStatus('Template Engine ƒë√£ s·∫µn s√†ng!', 'success');
        }).catch(error => {
          console.warn('‚ö†Ô∏è Template Engine initialization failed:', error);
          showStatus('Template Engine kh√¥ng kh·∫£ d·ª•ng - ch·ªâ c√≥ th·ªÉ l∆∞u v√†o DB', 'warning');
        });

        // Set default publish date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('publishDate').value = today;

        // Check if editing existing article
        console.log('üîç Starting URL parameter analysis...');
        const urlParams = new URLSearchParams(window.location.search);
        const editId = urlParams.get('edit');

        console.log('üåê URL Analysis:', {
          fullUrl: window.location.href,
          search: window.location.search,
          editId: editId,
          editIdType: typeof editId,
          editIdLength: editId ? editId.length : 0,
          allParams: Object.fromEntries(urlParams),
          hasEditParam: urlParams.has('edit'),
          rawEditValue: window.location.search.match(/edit=([^&]*)/)?.[1]
        });

        if (editId) {
          console.log('‚úèÔ∏è Edit mode detected with ID:', editId);
          console.log('üîç Current URL:', window.location.href);
          console.log('üîç Edit ID type:', typeof editId, 'Length:', editId.length);
          document.querySelector('.admin-header h1').textContent = '‚úèÔ∏è Ch·ªânh s·ª≠a b√†i vi·∫øt';

          // Wait for both Supabase and TinyMCE to be ready
          console.log('üöÄ Starting waitForSupabaseAndLoadArticle...');
          await waitForSupabaseAndLoadArticle(editId);
        } else {
          console.log('üìù Create new article mode');
        }

        console.log('‚úÖ Admin editor initialized successfully');
        showStatus('Admin interface ƒë√£ s·∫µn s√†ng!', 'success');
      } catch (error) {
        console.error('‚ùå App initialization failed:', error);
        showStatus('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng: ' + error.message, 'error');
      }
    }

    // Wait for Supabase to be ready and load article
    async function waitForSupabaseAndLoadArticle(articleId) {
      console.log('üéØ waitForSupabaseAndLoadArticle called with ID:', articleId);
      let attempts = 0;
      const maxAttempts = 10;

      while (attempts < maxAttempts) {
        try {
          console.log(`üîÑ Attempt ${attempts + 1}/${maxAttempts} to load article...`);

          // Try to get Supabase client
          console.log('üîç Calling initializeSupabase...');
          const client = await initializeSupabase();
          console.log('üîç Supabase client result:', client ? 'SUCCESS' : 'FAILED');

          if (client) {
            console.log('‚úÖ Supabase ready, proceeding to load article...');

            // Also wait for TinyMCE to be available
            if (typeof tinymce !== 'undefined' && tinymce.get('content')) {
              console.log('‚úÖ TinyMCE also ready');
            } else {
              console.log('‚ö†Ô∏è TinyMCE not fully ready yet, but continuing...');
            }

            console.log('üöÄ Calling loadArticleForEdit with ID:', articleId);
            await loadArticleForEdit(articleId);
            console.log('‚úÖ loadArticleForEdit completed successfully');
            return;
          } else {
            console.log('‚ùå Supabase client not ready, retrying...');
          }

          // Wait 500ms before next attempt
          await new Promise(resolve => setTimeout(resolve, 500));
          attempts++;
        } catch (error) {
          console.error(`‚ùå Attempt ${attempts + 1} failed:`, error);
          attempts++;
          if (attempts >= maxAttempts) {
            console.error('‚ùå All attempts failed to load article');
            showErrorModal(
              'Kh√¥ng th·ªÉ t·∫£i b√†i vi·∫øt',
              'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu sau nhi·ªÅu l·∫ßn th·ª≠. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i.'
            );
            break;
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      console.log('‚ùå waitForSupabaseAndLoadArticle finished without success');
    }

    // Load article for editing
    async function loadArticleForEdit(articleId) {
      try {
        console.log('üéØ loadArticleForEdit called with ID:', articleId);
        console.log('üîç Starting to load article for edit. ID type:', typeof articleId, 'Value:', articleId);
        showStatus('‚è≥ ƒêang t·∫£i b√†i vi·∫øt ƒë·ªÉ ch·ªânh s·ª≠a...', 'info');

        console.log('üîó Getting Supabase client...');
        const client = await initializeSupabase();
        if (!client) {
          console.error('‚ùå Supabase client not available');
          showStatus('‚ùå Ch∆∞a k·∫øt n·ªëi Supabase', 'error');
          return;
        }

        console.log('‚úÖ Supabase client ready, querying article...');

        // Test query to verify connection
        try {
          console.log('üß™ Running connection test...');
          const testQuery = await client
            .from('articles')
            .select('id, title')
            .limit(1);
          console.log('üîç Supabase connection test result:', testQuery);
        } catch (testError) {
          console.warn('‚ö†Ô∏è Supabase connection test failed:', testError);
        }

        console.log('üì° Executing main query for article ID:', articleId);
        const { data, error } = await client
          .from('articles')
          .select('*')
          .eq('id', articleId)
          .single();

        console.log('üìä Main query result:');
        console.log('- Data:', data);
        console.log('- Error:', error);
        console.log('- Article ID searched:', articleId);

        if (error) {
          console.error('‚ùå Database query error:', error);
          throw error;
        }

        if (!data) {
          console.error('‚ùå No article data returned');
          const errorMessage = `B√†i vi·∫øt v·ªõi ID "${articleId}" kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.`;
          showErrorModal('Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt', errorMessage);
          throw new Error(errorMessage);
        }

        console.log('‚úÖ Article data loaded:', data);
        console.log('üìã Article data details:', {
          id: data.id,
          title: data.title,
          description: data.description,
          category: data.category,
          status: data.status,
          content_length: data.content ? data.content.length : 0
        });

        // Fill form with article data
        console.log('üìù Starting to fill form with article data...');

        try {
          console.log('üîç Validating form elements exist...');
          // Validate form elements exist
          const requiredElements = ['title', 'description', 'category', 'publishDate', 'keywords', 'filename'];
          for (const elementId of requiredElements) {
            const element = document.getElementById(elementId);
            if (!element) {
              console.error(`‚ùå Form element not found: ${elementId}`);
              throw new Error(`Form element kh√¥ng t√¨m th·∫•y: ${elementId}`);
            } else {
              console.log(`‚úÖ Found form element: ${elementId}`);
            }
          }

          console.log('üìù Filling basic form fields...');
          // Fill basic fields
          document.getElementById('title').value = data.title || '';
          console.log('‚úÖ Title filled:', data.title);

          document.getElementById('description').value = data.description || '';
          console.log('‚úÖ Description filled:', data.description);

          document.getElementById('category').value = data.category || 'TIN T·ª®C';
          console.log('‚úÖ Category filled:', data.category);

          document.getElementById('publishDate').value = data.published_date || '';
          console.log('‚úÖ Publish date filled:', data.published_date);

          document.getElementById('keywords').value = data.keywords || '';
          console.log('‚úÖ Keywords filled:', data.keywords);

          document.getElementById('filename').value = data.filename || '';
          console.log('‚úÖ Filename filled:', data.filename);

          // Log article status for reference
          const articleStatus = data.status || (data.is_published ? 'published' : 'draft');
          console.log('‚úÖ Article status loaded:', articleStatus);

          console.log('‚úÖ Basic form fields filled successfully');
        } catch (fillError) {
          console.error('‚ùå Error filling form fields:', fillError);
          throw fillError;
        }

        // Load optional fields if they exist
        try {
          if (data.tags !== undefined) {
            const tagsElement = document.getElementById('tags');
            if (tagsElement) {
              tagsElement.value = data.tags || '';
              console.log('‚úÖ Tags field filled:', data.tags);
            }
          }

          if (data.is_featured !== undefined) {
            const featuredElement = document.getElementById('featured');
            if (featuredElement) {
              featuredElement.checked = data.is_featured || false;
              console.log('‚úÖ Featured field filled:', data.is_featured);
            }
          }

          // Load feature image if exists
          if (data.feature_image_url) {
            featureImage = {
              id: 'existing-' + Date.now(),
              name: 'Existing Feature Image',
              url: data.feature_image_url,
              supabase: true
            };
            showFeatureImagePreview(data.feature_image_url);
            console.log('‚úÖ Feature image loaded:', data.feature_image_url);
          }
        } catch (optionalError) {
          console.warn('‚ö†Ô∏è Error filling optional fields:', optionalError);
          // Continue execution even if optional fields fail
        }

        // Load content into TinyMCE
        console.log('üìù Loading content into TinyMCE...');
        console.log('üìÑ Content details:', {
          hasContent: !!data.content,
          contentLength: data.content ? data.content.length : 0,
          contentPreview: data.content ? data.content.substring(0, 100) + '...' : 'No content'
        });

        console.log('üîß Calling setTinyMCEContent...');
        setTinyMCEContent(data.content || '');
        console.log('‚úÖ Content loading initiated for TinyMCE');

        console.log('üíæ Storing article ID for future updates...');
        // Store article ID for updating
        window.currentEditingId = articleId;
        console.log('‚úÖ Article ID stored:', window.currentEditingId);

        showStatus('‚úÖ ƒê√£ t·∫£i b√†i vi·∫øt ƒë·ªÉ ch·ªânh s·ª≠a: ' + data.title, 'success');
        console.log('üéâ loadArticleForEdit completed successfully!');

      } catch (error) {
        console.error('‚ùå Error in loadArticleForEdit:', error);
        console.error('‚ùå Error stack:', error.stack);

        // Show error modal for article not found or other critical errors
        if (error.message.includes('kh√¥ng t·ªìn t·∫°i') || error.message.includes('not found')) {
          showErrorModal(
            'Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt',
            `B√†i vi·∫øt v·ªõi ID "${articleId}" kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a. Vui l√≤ng ki·ªÉm tra l·∫°i danh s√°ch b√†i vi·∫øt.`
          );
        } else {
          // For other errors, show modal with general error
          showErrorModal(
            'L·ªói t·∫£i b√†i vi·∫øt',
            `C√≥ l·ªói x·∫£y ra khi t·∫£i b√†i vi·∫øt: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c quay v·ªÅ dashboard.`
          );
        }

        // Also show status for debugging
        showStatus('‚ùå L·ªói t·∫£i b√†i vi·∫øt: ' + error.message, 'error');
      }
    }

    // ÔøΩ UPDATE NEWS PAGE FUNCTION
    async function updateNewsPage() {
      try {
        showStatus('üì∞ ƒêang c·∫≠p nh·∫≠t trang tin t·ª©c...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // L·∫•y t·∫•t c·∫£ b√†i vi·∫øt ƒë√£ published ƒë·ªÉ c·∫≠p nh·∫≠t trang tin t·ª©c
        // S·ª≠ d·ª•ng DISTINCT v√† s·∫Øp x·∫øp ƒë·ªÉ tr√°nh tr√πng l·∫∑p
        const { data: articles, error } = await client
          .from('articles')
          .select('id, title, description, content, category, keywords, filename, published_date, is_published, created_at, updated_at, feature_image_url')
          .eq('is_published', true)
          .order('updated_at', { ascending: false }) // ∆Øu ti√™n b√†i vi·∫øt ƒë∆∞·ª£c c·∫≠p nh·∫≠t g·∫ßn nh·∫•t
          .order('created_at', { ascending: false })  // Sau ƒë√≥ theo ng√†y t·∫°o
          .limit(20); // L·∫•y 20 b√†i ƒë·ªÉ c√≥ d·ª± ph√≤ng sau khi deduplicate

        if (error) {
          throw error;
        }

        if (!articles || articles.length === 0) {
          showStatus('‚ö†Ô∏è Kh√¥ng c√≥ b√†i vi·∫øt n√†o ƒë·ªÉ c·∫≠p nh·∫≠t trang tin t·ª©c', 'warning');
          return;
        }

        // Deduplicate theo filename ƒë·ªÉ tr√°nh tr√πng l·∫∑p b√†i vi·∫øt
        const uniqueArticles = [];
        const seenFilenames = new Set();
        const seenIds = new Set();

        for (const article of articles) {
          // Ki·ªÉm tra tr√πng l·∫∑p theo filename v√† id
          if (!seenFilenames.has(article.filename) && !seenIds.has(article.id)) {
            seenFilenames.add(article.filename);
            seenIds.add(article.id);
            uniqueArticles.push(article);
          }
        }

        // Ch·ªâ l·∫•y 15 b√†i sau khi deduplicate
        const finalArticles = uniqueArticles.slice(0, 15);

        showStatus(`üìä ƒê√£ l·ªçc ${finalArticles.length} b√†i vi·∫øt unique t·ª´ ${articles.length} b√†i trong database`, 'info');

        // Call Supabase Edge Function ƒë·ªÉ c·∫≠p nh·∫≠t tin-tuc.html
        const { data, error: updateError } = await client.functions.invoke('update-news-page', {
          body: {
            articles: finalArticles, // S·ª≠ d·ª•ng danh s√°ch ƒë√£ deduplicate
            total_count: articles.length, // G·ª≠i k√®m s·ªë l∆∞·ª£ng g·ªëc ƒë·ªÉ th·ªëng k√™
            unique_count: finalArticles.length,
            trigger_source: 'admin_interface'
          }
        });

        if (updateError) {
          throw updateError;
        }

        if (data && data.success) {
          showStatus(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t trang tin t·ª©c th√†nh c√¥ng! (${finalArticles.length} b√†i vi·∫øt unique)`, 'success');
          console.log('‚úÖ News page updated successfully:', {
            unique_articles: finalArticles.length,
            total_articles: articles.length,
            duplicates_removed: articles.length - finalArticles.length,
            response: data
          });
        } else {
          throw new Error('News page update returned false');
        }

      } catch (error) {
        console.error('‚ùå Update news page failed:', error);

        if (error.message?.includes('not found') || error.message?.includes('404')) {
          showStatus('‚ùå Edge Function "update-news-page" ch∆∞a ƒë∆∞·ª£c deploy!', 'error');
        } else {
          showStatus('‚ùå C·∫≠p nh·∫≠t trang tin t·ª©c th·∫•t b·∫°i: ' + error.message, 'error');
        }

        // Kh√¥ng throw error ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n qu√° tr√¨nh deploy ch√≠nh
        console.warn('‚ö†Ô∏è News page update failed but continuing with main deploy...');
      }
    }

    // ÔøΩüöÄ GITHUB AUTO-DEPLOY FUNCTIONS (VIA SUPABASE EDGE FUNCTION)
    async function triggerGitHubDeploy(article) {
      console.log('üöÄ Triggering GitHub deploy for:', article.filename);

      try {
        showStatus('üöÄ ƒêang kh·ªüi ƒë·ªông deploy GitHub Pages...', 'info');

        // C·∫≠p nh·∫≠t trang tin t·ª©c tr∆∞·ªõc khi deploy b√†i vi·∫øt
        await updateNewsPage();

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // Call Supabase Edge Function ƒë·ªÉ trigger GitHub deploy
        const { data, error } = await client.functions.invoke('deploy-article', {
          body: {
            article_id: article.id,
            trigger_source: 'admin_interface'
          }
        });

        if (error) {
          throw error;
        }

        if (data && data.success) {
          showStatus(`üéâ GitHub deploy ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông! File ${article.filename} s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông.`, 'success');
          console.log('‚úÖ GitHub deploy triggered successfully:', data);

          // Show deploy status
          setTimeout(() => {
            showStatus(`üîç Ki·ªÉm tra GitHub Actions: https://github.com/Liam-and-Son-Group/baoviet-danang/actions`, 'info');
          }, 2000);

        } else {
          throw new Error('Deploy trigger returned false');
        }

      } catch (error) {
        console.error('‚ùå GitHub deploy trigger failed:', error);

        if (error.message?.includes('not found') || error.message?.includes('404')) {
          showStatus('‚ùå Edge Function ch∆∞a ƒë∆∞·ª£c deploy. Vui l√≤ng deploy function "deploy-article" tr∆∞·ªõc!', 'error');
        } else {
          showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
        }

        throw error;
      }
    }    // Manual deploy function cho n√∫t ri√™ng
    async function manualDeploy() {
      try {
        const filename = document.getElementById('filename').value;
        if (!filename) {
          showStatus('‚ùå Vui l√≤ng nh·∫≠p filename tr∆∞·ªõc khi deploy!', 'error');
          return;
        }

        showStatus('üîç ƒêang t√¨m b√†i vi·∫øt ƒë·ªÉ deploy...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        // T√¨m b√†i vi·∫øt theo filename
        const { data: articles, error } = await client
          .from('articles')
          .select('*')
          .eq('filename', filename)
          .single();

        if (error || !articles) {
          showStatus('‚ùå Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt v·ªõi filename n√†y trong database!', 'error');
          return;
        }

        await triggerGitHubDeploy(articles);

      } catch (error) {
        console.error('‚ùå Manual deploy failed:', error);
        showStatus('‚ùå Deploy th·∫•t b·∫°i: ' + error.message, 'error');
      }
    }

    // Check deploy status function
    async function checkDeployStatus() {
      try {
        showStatus('üìä ƒêang ki·ªÉm tra deploy logs...', 'info');

        // Get Supabase client
        const client = await initializeSupabase();
        if (!client) {
          throw new Error('Supabase client not initialized');
        }

        const { data, error } = await client
          .from('webhook_logs')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(5);

        if (error) {
          throw error;
        }

        console.log('üìä Recent deploy logs:', data);

        const recentLogs = data.map(log => {
          const payload = log.payload?.client_payload || {};
          const time = new Date(log.created_at).toLocaleString('vi-VN');
          return `[${time}] ${payload.article_filename || 'Unknown'} - ${log.status}`;
        }).join('\n');

        showStatus(`üìä Deploy logs (5 g·∫ßn nh·∫•t):\n${recentLogs}`, 'info');

      } catch (error) {
        console.error('‚ùå Check deploy status failed:', error);
        showStatus('‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra deploy status: ' + error.message, 'error');
      }
    }

    window.triggerGitHubDeploy = triggerGitHubDeploy;
    window.manualDeploy = manualDeploy;
    window.checkDeployStatus = checkDeployStatus;
    window.updateNewsPage = updateNewsPage;

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeApp);

    // Logout function
    // Enhanced Notification Modal System
    function showNotificationModal(options) {
      const {
        type = 'info', // 'loading', 'success', 'warning', 'error', 'question'
        icon = 'üíæ',
        title = 'Th√¥ng b√°o',
        message = '',
        buttons = [],
        autoClose = false,
        closeTime = 3000,
        showCloseButton = true
      } = options;

      const modal = document.getElementById('notificationModal');
      const iconEl = document.getElementById('notificationIcon');
      const titleEl = document.getElementById('notificationTitle');
      const messageEl = document.getElementById('notificationMessage');
      const buttonsEl = document.getElementById('notificationButtons');
      const closeBtn = document.getElementById('notificationCloseBtn');

      if (!modal) return;

      // Set content
      iconEl.textContent = icon;
      titleEl.textContent = title;
      messageEl.textContent = message;

      // Clear previous type classes
      modal.className = 'notification-modal show ' + type;

      // Show/hide close button (hide for loading modals)
      if (closeBtn) {
        closeBtn.style.display = (type !== 'loading' && showCloseButton) ? 'flex' : 'none';
      }

      // Clear and add buttons
      buttonsEl.innerHTML = '';
      buttons.forEach(button => {
        const btn = document.createElement('button');
        btn.textContent = button.text;
        btn.className = `notification-modal-button ${button.type || 'primary'}`;
        btn.onclick = () => {
          if (button.action) button.action();
          hideNotificationModal();
        };
        buttonsEl.appendChild(btn);
      });

      // Show modal
      modal.style.display = 'flex';

      // Auto close if specified
      if (autoClose) {
        setTimeout(() => {
          hideNotificationModal();
        }, closeTime);
      }

      return modal;
    }

    function hideNotificationModal() {
      const modal = document.getElementById('notificationModal');
      if (modal) {
        modal.style.display = 'none';
        modal.className = 'notification-modal';
      }
    }

    function handleNotificationBackdropClick(event) {
      if (event.target === event.currentTarget) {
        // Only close if not a loading modal
        const modal = event.currentTarget;
        if (!modal.classList.contains('loading')) {
          hideNotificationModal();
        }
      }
    }

    // Convenient wrapper functions
    function showLoadingModal(title = 'ƒêang x·ª≠ l√Ω...', message = 'Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t.') {
      return showNotificationModal({
        type: 'loading',
        icon: 'üíæ',
        title: title,
        message: message,
        buttons: [],
        showCloseButton: false
      });
    }

    function showSuccessModal(title = 'Th√†nh c√¥ng!', message = '', autoClose = true) {
      return showNotificationModal({
        type: 'success',
        icon: '‚úÖ',
        title: title,
        message: message,
        buttons: [{
          text: 'üëç OK',
          type: 'primary'
        }],
        autoClose: autoClose,
        closeTime: 3000
      });
    }

    function showWarningModal(title = 'C·∫£nh b√°o', message = '', buttons = []) {
      return showNotificationModal({
        type: 'warning',
        icon: '‚ö†Ô∏è',
        title: title,
        message: message,
        buttons: buttons.length > 0 ? buttons : [{
          text: 'üëç ƒê√£ hi·ªÉu',
          type: 'primary'
        }]
      });
    }

    function showErrorNotification(title = 'C√≥ l·ªói x·∫£y ra', message = '') {
      return showNotificationModal({
        type: 'error',
        icon: '‚ùå',
        title: title,
        message: message,
        buttons: [{
          text: 'üëç OK',
          type: 'danger'
        }]
      });
    }

    function showQuestionModal(title = 'X√°c nh·∫≠n', message = '', onYes = null, onNo = null) {
      return showNotificationModal({
        type: 'question',
        icon: '‚ùì',
        title: title,
        message: message,
        buttons: [
          {
            text: '‚úÖ C√≥',
            type: 'primary',
            action: onYes
          },
          {
            text: '‚ùå Kh√¥ng',
            type: 'secondary',
            action: onNo
          }
        ]
      });
    }

    // Legacy Error Modal Functions - keeping for compatibility
    function showErrorModal(title, message) {
      const modal = document.getElementById('errorModal');
      const titleEl = modal.querySelector('.error-modal-title');
      const messageEl = document.getElementById('errorModalMessage');

      if (title) titleEl.textContent = title;
      if (message) messageEl.textContent = message;

      modal.classList.add('show');
      console.log('üö® Error modal displayed:', title, message);

      // Add ESC key listener
      document.addEventListener('keydown', handleModalEscape);
    }

    function hideErrorModal() {
      const modal = document.getElementById('errorModal');
      modal.classList.remove('show');
      document.removeEventListener('keydown', handleModalEscape);
    }

    function handleModalEscape(event) {
      if (event.key === 'Escape') {
        hideErrorModal();
      }
    }

    function handleModalBackdropClick(event) {
      if (event.target === event.currentTarget) {
        hideErrorModal();
      }
    }

    function goBackToDashboard() {
      console.log('üè† Redirecting to dashboard...');
      window.location.href = 'admin-dashboard.html';
    }

    // Debug function - call from browser console to test loading a specific article
    window.debugLoadArticle = function (articleId) {
      console.log('üß™ DEBUG: Testing article loading for ID:', articleId);
      loadArticleForEdit(articleId).catch(error => {
        console.error('üß™ DEBUG: Article loading failed:', error);
      });
    };

    // Configure Supabase function
    function configureSupabase() {
      const currentKey = localStorage.getItem('supabase_anon_key');
      const newKey = prompt(
        'Nh·∫≠p Supabase Anon Key m·ªõi:' + (currentKey ? '\n\nHi·ªán t·∫°i: ' + currentKey.substring(0, 20) + '...' : ''),
        currentKey || ''
      );

      if (newKey && newKey !== currentKey) {
        localStorage.setItem('supabase_anon_key', newKey);
        SUPABASE_CONFIG.anonKey = newKey;

        // Reset Supabase client to force reinitialization
        supabase = null;
        supabaseInitialized = false;

        showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t Supabase Anon Key. Reload trang ƒë·ªÉ √°p d·ª•ng.', 'success');

        // Ask if user wants to reload
        if (confirm('Reload trang ƒë·ªÉ √°p d·ª•ng c·∫•u h√¨nh m·ªõi?')) {
          window.location.reload();
        }
      } else if (newKey === '') {
        // User wants to clear the key
        localStorage.removeItem('supabase_anon_key');
        SUPABASE_CONFIG.anonKey = null;
        supabase = null;
        supabaseInitialized = false;
        showStatus('üóëÔ∏è ƒê√£ x√≥a Supabase Anon Key', 'info');
      }
    }

    function logout() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒëƒÉng xu·∫•t?')) {
        sessionStorage.clear();
        window.location.href = 'admin-login.html';
      }
    }

  </script>

  <!-- Error Modal -->
  <div id="errorModal" class="error-modal" onclick="handleModalBackdropClick(event)">
    <div class="error-modal-content" onclick="event.stopPropagation()">
      <div class="error-modal-icon">‚ùå</div>
      <div class="error-modal-title">Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt</div>
      <div class="error-modal-message" id="errorModalMessage">
        B√†i vi·∫øt v·ªõi ID ƒë∆∞·ª£c y√™u c·∫ßu kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.
      </div>
      <button class="error-modal-button" onclick="goBackToDashboard()">
        üè† Quay v·ªÅ Dashboard
      </button>
    </div>
  </div>

  <!-- Enhanced Notification Modal -->
  <div id="notificationModal" class="notification-modal" onclick="handleNotificationBackdropClick(event)">
    <div class="notification-modal-content" onclick="event.stopPropagation()">
      <button class="notification-modal-close" onclick="hideNotificationModal()" id="notificationCloseBtn"
        style="display: none;">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13 1L1 13M1 1L13 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"
            stroke-linejoin="round" />
        </svg>
      </button>
      <div class="notification-modal-icon" id="notificationIcon">üíæ</div>
      <div class="notification-modal-title" id="notificationTitle">ƒêang l∆∞u...</div>
      <div class="notification-modal-message" id="notificationMessage">
        Vui l√≤ng ƒë·ª£i trong khi h·ªá th·ªëng l∆∞u b√†i vi·∫øt c·ªßa b·∫°n.
      </div>
      <div class="notification-modal-buttons" id="notificationButtons">
        <!-- Buttons will be added dynamically -->
      </div>
    </div>
  </div>

</body>

</html>